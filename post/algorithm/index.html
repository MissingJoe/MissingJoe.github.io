<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.96.0" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title> &middot; Work space for MissingJoe</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="https://MissingJoe.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://MissingJoe.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://MissingJoe.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://MissingJoe.github.io/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  
</head>

  <body class="theme-base-08 ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://MissingJoe.github.io/"><h1>Work space for MissingJoe</h1></a>
      <p class="lead">
       Welcome to my personal blog. Hope there are some good notes helpfull for you here. 
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://MissingJoe.github.io/">Home</a> </li>
        
      </ul>
    </nav>

    <p>&copy; 2022. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1></h1>
  <time datetime=0001-01-01T00:00:00Z class="post-date">Mon, Jan 1, 0001</time>
  <p>[toc]</p>
<h1 id="第一讲">第一讲</h1>
<h2 id="part-1--时间复杂度">Part 1  时间复杂度</h2>
<h3 id="简单的例子理解时间复杂度">简单的例子理解时间复杂度</h3>
<p>一个有序数组A，另一个无序数组B，打印B数组中不在A数组中的数，假设A长度N，B长度M</p>
<p>三种方法：</p>
<ol>
<li>
<p>遍历B数组，每遍历一次B，直接遍历一次A数组看看有没有**（暴力法  O(MN)）**</p>
</li>
<li>
<p>遍历B数组，每遍历一次B，二分遍历一次A数组看看有没有**（二分查找  O(Mlog~2~N)）**</p>
</li>
<li>
<p>先把B排序，这时两个数组均有序，然后利用双指针思想，开始均指向数组的头。A中的值==小于==B中的值，A指针自增（<strong>说明当前B值在A值后方，有没有不知道</strong>），A中的值==等于==B中的值，B指针自增（<strong>说明当前B值在A中不输出，则直接找下一个，因为数组均排序，下一个数一定大，所以不存在漏找的情况</strong>），中的值==大于==B中的值，输出B元素，B指针自增（<strong>说明A中没有当前的B元素直接输出</strong>） （<strong>排序最好O(Mlog~2~M)+输出O(MN)   不一定比方法2好，分析N的值</strong>）。合并有序数组merge</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printUnionAWithoutUnionB</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> b[], <span style="color:#66d9ef">int</span> m, <span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> a1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, b1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (a1 <span style="color:#f92672">&lt;</span> m <span style="color:#f92672">&amp;&amp;</span> b1 <span style="color:#f92672">&lt;</span> n) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (a[a1] <span style="color:#f92672">&lt;</span> b[b1])
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">++</span>a1;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (a[a1] <span style="color:#f92672">==</span> b[b1])
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">++</span>b1;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>			cout <span style="color:#f92672">&lt;&lt;</span> b[b1<span style="color:#f92672">++</span>] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (b1 <span style="color:#f92672">&lt;</span> n)
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> b[b1<span style="color:#f92672">++</span>] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ol>
<h2 id="part-2--对数器">Part 2  对数器</h2>
<p>对数器：比赛中debug用，样例过了，测试过不去</p>
<ol>
<li>有一个要测的方法a</li>
<li>实现一个绝对正确复杂度无所谓的方法b，可以用自带的库等等暴力方法</li>
<li>测试样本随机产生器，产生大量样本</li>
<li>ab方法结果比对，不对的样本打印一下看结果</li>
</ol>
<p><strong>其实就是自己造样本测试</strong></p>
<h2 id="part-3--归并排序">Part 3  归并排序</h2>
<h3 id="递归复杂度分析">递归复杂度分析</h3>
<p>下来介绍递归的复杂度，master公式</p>
<p>如果递归方程可以写成如下形式   $O(n)=a*O(\frac{n}{b})+O(n^{d})$</p>
<ol>
<li>$log_b a&gt;d$  &ndash;&gt;  $O(n^{log_b a})$</li>
<li>$log_b a=d$  &ndash;&gt;  $O(n^{d}*logn)$</li>
<li>$log_b a&lt;d$  &ndash;&gt;  $O(n^{d})$</li>
</ol>
<h3 id="各种排序">各种排序</h3>
<p>冒泡：从头到尾遍历，两两比较，每一次把最大的数放到最后，每次遍历的次数减一    <strong>O(n^2^)</strong></p>
<p>直接插入：遍历每个数，往前找第一个比他小的数，把他放在前面   <strong>O(n^2^)</strong></p>
<p>选择：从后n个数中选择最小的放在当前遍历位置上    <strong>O(n^2^)</strong></p>
<p>归并排序：把数组分两半，分别排序，再合并</p>
<p>​                   递归方程 $O(n)=2*O(n/2)+O(n)$        复杂度为<strong>O(nlogn)</strong></p>
<h3 id="利用归并排序快速解决一个问题小和问题和逆序对问题">利用归并排序快速解决一个问题小和问题和逆序对问题</h3>
<p><strong>小和问题</strong>：一个数组中，每个数左边比当前数小的数的和为数组小和，求数组小和</p>
<p>​                   输入：1，3，4，2，5</p>
<p>​                   输出：1+1+3+1+1+3+4+2=16</p>
<ol>
<li>暴力遍历，每个数都向左边遍历一次，求和     <strong>O(n^2^)  求数组每个数左边比它小的数的和</strong></li>
<li>归并排序<strong>求每个数右边比它大的数的个数，乘这个数求和就完成了O(nlogn)</strong>，归并排序的过程巧妙的契合这个过程。归并排序的核心就是合并操作，在两个半长数组合并时，首先两边的数组都排过序，当左边的数小于右边的数，就出现了小和，由于右边的数组排过序，所以右边有多少个数比左边大也知道，小和可计算，而且再进行合并的时候右边的数组和之前的不一样，所以不存在重复的情况。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Merge</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> mid, <span style="color:#66d9ef">int</span> r, <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> count) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> l, b <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> help<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[r <span style="color:#f92672">-</span> l <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];<span style="color:#75715e">//构造辅助数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> (h <span style="color:#f92672">&lt;=</span> mid <span style="color:#f92672">&amp;&amp;</span> b <span style="color:#f92672">&lt;=</span> r) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (a[h] <span style="color:#f92672">&lt;=</span> a[b]) {
</span></span><span style="display:flex;"><span>			help[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> a[h];
</span></span><span style="display:flex;"><span>			count <span style="color:#f92672">+=</span> a[h<span style="color:#f92672">++</span>] <span style="color:#f92672">*</span> (r <span style="color:#f92672">-</span> b <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);<span style="color:#75715e">//出现小和，计数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> 
</span></span><span style="display:flex;"><span>			help[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> a[b<span style="color:#f92672">++</span>]; 
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (h <span style="color:#f92672">&lt;=</span> mid)
</span></span><span style="display:flex;"><span>		help[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> a[h<span style="color:#f92672">++</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (b <span style="color:#f92672">&lt;=</span> r)
</span></span><span style="display:flex;"><span>		help[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> a[b<span style="color:#f92672">++</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> r <span style="color:#f92672">-</span> l <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		a[l <span style="color:#f92672">+</span> i] <span style="color:#f92672">=</span> help[i];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">delete</span>[]help;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">MergeSort</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> l,<span style="color:#66d9ef">int</span> r,<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>count) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (l <span style="color:#f92672">==</span> r)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> mid1 <span style="color:#f92672">=</span> l <span style="color:#f92672">+</span> ((r <span style="color:#f92672">-</span> l) <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>);<span style="color:#75715e">//防止mid溢出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	MergeSort(a, l, mid1, count);
</span></span><span style="display:flex;"><span>	MergeSort(a, mid1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, r, count);
</span></span><span style="display:flex;"><span>	Merge(a, l, mid1, r, count);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>逆序对问题</strong>：一个数组中，左边的数比右边的数大，这两个数构成一个逆序对，打印所有逆序对。</p>
<ol>
<li>暴力遍历，每个数都向左边遍历一次，符合条件打印    **O(n^2^)  **</li>
<li>归并排序<strong>左边数比右边大，右边的数的右边打印即可    O(nlogn)</strong></li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Merge</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> mid, <span style="color:#66d9ef">int</span> r) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> l, b <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> help<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[r <span style="color:#f92672">-</span> l <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (h <span style="color:#f92672">&lt;=</span> mid <span style="color:#f92672">&amp;&amp;</span> b <span style="color:#f92672">&lt;=</span> r) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (a[h] <span style="color:#f92672">&gt;</span> a[b]) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> b; j <span style="color:#f92672">&lt;=</span> r; <span style="color:#f92672">++</span>j)
</span></span><span style="display:flex;"><span>				cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;(&#34;</span> <span style="color:#f92672">&lt;&lt;</span> a[h] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;,&#34;</span> <span style="color:#f92672">&lt;&lt;</span> a[j] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>			help[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> a[h<span style="color:#f92672">++</span>];
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> 
</span></span><span style="display:flex;"><span>			help[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> a[b<span style="color:#f92672">++</span>]; 
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (h <span style="color:#f92672">&lt;=</span> mid)
</span></span><span style="display:flex;"><span>		help[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> a[h<span style="color:#f92672">++</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (b <span style="color:#f92672">&lt;=</span> r)
</span></span><span style="display:flex;"><span>		help[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> a[b<span style="color:#f92672">++</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> r <span style="color:#f92672">-</span> l <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		a[l <span style="color:#f92672">+</span> i] <span style="color:#f92672">=</span> help[i];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">delete</span>[]help;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">MergeSort</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> l,<span style="color:#66d9ef">int</span> r) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (l <span style="color:#f92672">==</span> r)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> mid1 <span style="color:#f92672">=</span> l <span style="color:#f92672">+</span> ((r <span style="color:#f92672">-</span> l) <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	MergeSort(a, l, mid1);
</span></span><span style="display:flex;"><span>	MergeSort(a, mid1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, r);
</span></span><span style="display:flex;"><span>	Merge(a, l, mid1, r);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="第二讲">第二讲</h1>
<h2 id="part-1--改进快排">Part 1  改进快排</h2>
<h3 id="加速快排的引入荷兰国旗问题">加速快排的引入荷兰国旗问题：</h3>
<p>给定一个数组和一个数num，数组中小于num的数放在左边，等于num的数放在中间，大于num的数放在右边。要求空间复杂度O(1)，时间复杂度O(n)</p>
<p>有大有小要用双指针，遍历数组一次，当前数记为cur，小于区域指针low，大于区域指针high，low high指针全部指向小于区域和大于区域的最后一个元素</p>
<ol>
<li>cur=num，cur++，low high不变</li>
<li>cur&lt;num，首先交换low的下一个位置和cur，low++，cur++。这里分两种情况，1)没有等于区域，那么low++和cur是一个数，此时low++，cur++，小于区域扩充一个，遍历下一个。2)有等于区域，此时low++的元素=num，这时候交换到cur位置的元素=num，low++，cur++，小于区域扩充一个，cur位置元素=num，继续往前便利。</li>
<li>cur&gt;num，首先交换high的下一个位置(与遍历的方向相反)，high++，cur<strong>不变</strong>。这里大于区域的前一个元素是待定的，所以换到cur的元素不确定大小，不能动，high扩充一个。</li>
<li>cur=high，遍历结束。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Swap</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">int</span> j) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> a[i];
</span></span><span style="display:flex;"><span>	a[i] <span style="color:#f92672">=</span> a[j];
</span></span><span style="display:flex;"><span>	a[j] <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Netherland</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> L, <span style="color:#66d9ef">int</span> R, <span style="color:#66d9ef">int</span> num) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> cur <span style="color:#f92672">=</span> L, low <span style="color:#f92672">=</span> L <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, high <span style="color:#f92672">=</span> R <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (cur <span style="color:#f92672">!=</span> high) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (a[cur] <span style="color:#f92672">==</span> num)
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">++</span>cur;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (a[cur] <span style="color:#f92672">&gt;</span> num)
</span></span><span style="display:flex;"><span>			Swap(a, cur, <span style="color:#f92672">--</span>high);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>			Swap(a, cur<span style="color:#f92672">++</span>, <span style="color:#f92672">++</span>low);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="经典快排存在的问题">经典快排存在的问题</h3>
<ol>
<li>每次只解决了一个位置的数，利用荷兰国旗问题就可以将数组中和每次指定的数相同的数位置全部确定，这样就加速了快排。由于荷兰国旗问题从low开始遍历，所以标志选择为数组最后一个数。</li>
<li>考虑最差的情况，指定的标志是数组最大的数或者最小的数，排一次所有数都在标志的左边或者右边，这样快排的复杂度退化到了<strong>O(n^2^)</strong>，所以我们每次不要取最后一个数或者第一个数作为标志，随机选一个。</li>
<li>快排不稳定。<strong>无解</strong></li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Swap</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">int</span> j) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> a[i];
</span></span><span style="display:flex;"><span>	a[i] <span style="color:#f92672">=</span> a[j];
</span></span><span style="display:flex;"><span>	a[j] <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">Partition</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> L, <span style="color:#66d9ef">int</span> R, <span style="color:#66d9ef">int</span> num) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> cur <span style="color:#f92672">=</span> L, low <span style="color:#f92672">=</span> L <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, high <span style="color:#f92672">=</span> R <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (cur <span style="color:#f92672">!=</span> high) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (a[cur] <span style="color:#f92672">==</span> num)
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">++</span>cur;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (a[cur] <span style="color:#f92672">&gt;</span> num)
</span></span><span style="display:flex;"><span>			Swap(a, cur, <span style="color:#f92672">--</span>high);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>			Swap(a, cur<span style="color:#f92672">++</span>, <span style="color:#f92672">++</span>low);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> mid <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>	mid[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> low <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	mid[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> high <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> mid;<span style="color:#75715e">//返回相等区域的首地址和尾地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">QuickSort</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> L, <span style="color:#66d9ef">int</span> R) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (L <span style="color:#f92672">&lt;</span> R) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> RandLoc <span style="color:#f92672">=</span> L <span style="color:#f92672">+</span> rand() <span style="color:#f92672">%</span> (R <span style="color:#f92672">-</span> L <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);<span style="color:#75715e">//产生随机数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>mid<span style="color:#f92672">=</span>Partition(a, L, R, a[RandLoc]);
</span></span><span style="display:flex;"><span>		QuickSort(a, L, mid[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>		QuickSort(a, mid[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, R);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">delete</span>[]mid;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="part-2--快排与归并排序的一些异同">Part 2  快排与归并排序的一些异同</h2>
<ol>
<li>数据量巨大，快排比归并快，快在常数项，归并的常数操作更多，常数时间长。</li>
<li>归并稳定，快排不稳。</li>
<li>归并空间复杂度<strong>O(n)</strong>，改进快排空间复杂度<strong>O(log~2~n)</strong>，改进快排需要记录每次Partition的相等区域首尾地址，这是一个二分记录的过程，所以额外空间复杂度 log~2~n</li>
<li>工程中不用递归，递归需要记录大量的递归信息，所以复杂度太高</li>
</ol>
<h2 id="part-3--堆排序">Part 3  堆排序</h2>
<p>堆调整算法：从根结点开始，直到叶子结点，看左右孩子和根是不是满足大/小顶堆，满足即可结束堆调整。不满足则交换根和左右孩子里面最大/最小的孩子，继续以左右孩子里面最大/最小的孩子为根重复以上过程。</p>
<p>建立堆：从最后一个非叶结点开始倒退遍历到整个树的根，从该结点为根进行堆调整</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">HeapAdjust</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> root, <span style="color:#66d9ef">int</span> length) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> a[root];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> root; i <span style="color:#f92672">&lt;=</span> length; i <span style="color:#f92672">*=</span> <span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> length <span style="color:#f92672">&amp;&amp;</span> a[i] <span style="color:#f92672">&lt;</span> a[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>])<span style="color:#75715e">//i&lt;length保证当前根节点该有右孩子，2*i在左孩子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#f92672">++</span>i;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (a[root] <span style="color:#f92672">&gt;</span> a[i])<span style="color:#75715e">//构成大顶就退出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		a[root] <span style="color:#f92672">=</span> a[i];
</span></span><span style="display:flex;"><span>		root <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	a[root] <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">HeapSort</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> length) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> length <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>i)
</span></span><span style="display:flex;"><span>		HeapAdjust(a, i, length);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> length; i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>		Swap(a, <span style="color:#ae81ff">1</span>, i);
</span></span><span style="display:flex;"><span>		HeapAdjust(a, <span style="color:#ae81ff">1</span>, i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>堆结构很重要</strong>，调整堆<strong>O(log~2~n)</strong></p>
<h2 id="part-4--工程中的排序方法">Part 4  工程中的排序方法</h2>
<ol>
<li>大数据量元素类型为基础类型，不需要考虑稳定性，快排。元素类型为自定义类型，需要稳定性，归并。</li>
<li>数据量很小，直接用插入排序，速度更快。</li>
</ol>
<h2 id="part-5--桶排序">Part 5  桶排序</h2>
<h3 id="桶排序元素类型int不同于之前的各种排序比较排序">桶排序(元素类型int)，不同于之前的各种排序(比较排序)</h3>
<ol>
<li>建立数组长度加1个桶存数据，桶数据自身排序，桶编号  $loc=\frac{(num-min)}{(max-min)}*len$，总共length+1个桶，桶编号0~length</li>
<li>每个桶里面排序</li>
<li>输出各个桶中元素</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">BucketNum</span>(<span style="color:#66d9ef">int</span> max, <span style="color:#66d9ef">int</span> min, <span style="color:#66d9ef">int</span> num, <span style="color:#66d9ef">int</span> length) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> (num <span style="color:#f92672">-</span> min) <span style="color:#f92672">/</span> (max <span style="color:#f92672">-</span> min) <span style="color:#f92672">*</span> length;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">BucketSort</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> length) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span>  low <span style="color:#f92672">=</span> a[<span style="color:#ae81ff">0</span>], high <span style="color:#f92672">=</span> a[<span style="color:#ae81ff">0</span>], index <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> v(length <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> length; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>		low <span style="color:#f92672">=</span> min(low, a[i]);
</span></span><span style="display:flex;"><span>		high <span style="color:#f92672">=</span> max(high, a[i]);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> length; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> num <span style="color:#f92672">=</span> BucketNum(high, low, a[i], length);<span style="color:#75715e">//确定桶号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		v[num].push_back(a[i]);<span style="color:#75715e">//进桶
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> length; <span style="color:#f92672">++</span>i) {<span style="color:#75715e">//桶里面排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		sort(v[i].begin(), v[i].end());
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> length; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>v[i].empty()) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span> (vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator it <span style="color:#f92672">=</span> v[i].begin(); it <span style="color:#f92672">!=</span> v[i].end(); <span style="color:#f92672">++</span>it) {
</span></span><span style="display:flex;"><span>				a[index<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>it;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>桶排序时间复杂度期望<strong>O(n)</strong>，尽量选更多的桶，桶里面元素尽量少。</p>
<hr>
<h3 id="利用桶排序的思想解决一个问题">利用桶排序的思想解决一个问题</h3>
<p>给定一个无序数组，求排序后数组中相邻两个数的最大差值，要求时间复杂度<strong>O(n)</strong></p>
<p>分析：如果用比较排序的话时间不可能这么快，采用桶的思想，求出最大值最小值，如果max=min直接返回0，否则，根据$loc=\frac{(num-min)}{(max-min)}*len$  准备length+1个桶，由于最小值在0号桶，最大值在max号桶，所以肯定有一个1~length-1号桶肯定有一个空桶。这样最大差值肯定不是一个桶内不同数的差值，因为空桶相邻的两个桶差值最小大于单个桶内差值的最大值。数据进每个桶，用max和min分别记录每个桶的最大值最小值，遍历每个桶更新桶间差值最大值，遍历一次即可求出答案</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Bucket</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> max;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> min;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> isempty;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">BucketNum</span>(<span style="color:#66d9ef">int</span> max, <span style="color:#66d9ef">int</span> min, <span style="color:#66d9ef">int</span> num, <span style="color:#66d9ef">int</span> length) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> ((num <span style="color:#f92672">-</span> min) <span style="color:#f92672">*</span> length) <span style="color:#f92672">/</span> (max <span style="color:#f92672">-</span> min);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">BucketFind</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> length) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span>  low <span style="color:#f92672">=</span> a[<span style="color:#ae81ff">0</span>], high <span style="color:#f92672">=</span> a[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> length; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>		low <span style="color:#f92672">=</span> min(low, a[i]);
</span></span><span style="display:flex;"><span>		high <span style="color:#f92672">=</span> max(high, a[i]);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (high <span style="color:#f92672">==</span> low)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		vector<span style="color:#f92672">&lt;</span>Bucket<span style="color:#f92672">&gt;</span> v(length <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> length; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>			v[i].isempty <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> length; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> num <span style="color:#f92672">=</span> BucketNum(high, low, a[i], length);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (v[num].isempty) {
</span></span><span style="display:flex;"><span>				v[num].isempty <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>				v[num].max <span style="color:#f92672">=</span> a[i];
</span></span><span style="display:flex;"><span>				v[num].min <span style="color:#f92672">=</span> a[i];
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>				v[num].max <span style="color:#f92672">=</span> max(v[num].max, a[i]);
</span></span><span style="display:flex;"><span>				v[num].min <span style="color:#f92672">=</span> min(v[num].min, a[i]);
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, lastmax<span style="color:#f92672">=</span>v[<span style="color:#ae81ff">0</span>].max;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> length; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>v[i].isempty) {
</span></span><span style="display:flex;"><span>				ans <span style="color:#f92672">=</span> max(ans, v[i].min <span style="color:#f92672">-</span> lastmax);
</span></span><span style="display:flex;"><span>				lastmax <span style="color:#f92672">=</span> v[i].max;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="第三讲">第三讲</h1>
<h2 id="part-1--栈与队列">Part 1  栈与队列</h2>
<h3 id="设计特殊的栈pushpopgetmin操作全部o1">设计特殊的栈，push、pop、getmin操作全部O(1)</h3>
<p>利用两个普通栈实现。除了数据栈还需要一个最小值栈保持和数组一样的高度，数据栈pop最小值栈pop，数据栈push最小值栈取出栈顶元素和进栈元素比较，较小的值进栈。这样不管何时最小值栈的栈顶都是数据栈的最小值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> num, min;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">push</span>(<span style="color:#66d9ef">int</span> number) {
</span></span><span style="display:flex;"><span>	num.push(number);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>min.empty())
</span></span><span style="display:flex;"><span>		min.push((min.top <span style="color:#f92672">&lt;</span> number) <span style="color:#f92672">?</span> min.top() <span style="color:#f92672">:</span> number);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		min.push(number);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">pop</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>num.empty()) {
</span></span><span style="display:flex;"><span>		num.pop();
</span></span><span style="display:flex;"><span>		min.pop();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> 
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;stack is empty!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">top</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> num.top();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getmin</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> min.top();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="仅用队列机构实现栈结构">仅用队列机构实现栈结构</h3>
<p>使用两个队列分别为help和data，进栈把数据push进data队列，退栈把data队列除队尾以外的数据出队列进help队列，最后一个数据出队列即为所求，之后交换help和data队列即可满足，每次进栈都进data队列</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> num, help;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">push</span>(<span style="color:#66d9ef">int</span> number) {
</span></span><span style="display:flex;"><span>	num.push(number);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">pop</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (num.size() <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>		help.push(num.front());
</span></span><span style="display:flex;"><span>		num.pop();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	num.pop();
</span></span><span style="display:flex;"><span>	queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>temp <span style="color:#f92672">=</span> num;
</span></span><span style="display:flex;"><span>	num <span style="color:#f92672">=</span> help;
</span></span><span style="display:flex;"><span>	help <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">top</span>() {
</span></span><span style="display:flex;"><span>	help <span style="color:#f92672">=</span> num;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> num.back();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>num.empty())
</span></span><span style="display:flex;"><span>		num.pop();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="仅用栈结构实现队列结构">仅用栈结构实现队列结构</h3>
<p>用两个栈，一个a一个b，进队列就往a里面push，出队列就把a里面的数据pop以后push进入b栈，取栈顶就得到了出队列的数据，再把b栈的数据全部push进a栈，结束。</p>
<h2 id="part-3--矩阵问题">Part 3  矩阵问题</h2>
<h3 id="转圈打印矩阵">转圈打印矩阵</h3>
<p>样例矩阵 <strong>额外空间O(1)</strong></p>
<p>1 2 3 4</p>
<p>4 5 6 7                          打印：1 2 3 4 7 11 10 9 8 4 5 6</p>
<p>8 9 10 11</p>
<p>一次打印外边的一层数，递归往里面。处理边界即可。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PrintNum</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">**</span> a, <span style="color:#66d9ef">int</span> uR, <span style="color:#66d9ef">int</span> uC, <span style="color:#66d9ef">int</span> dR, <span style="color:#66d9ef">int</span> dC) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (uR <span style="color:#f92672">==</span> dR) {<span style="color:#75715e">//只有一行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> uC; i <span style="color:#f92672">&lt;=</span> dC; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>			cout <span style="color:#f92672">&lt;&lt;</span> a[uR][i] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (uC <span style="color:#f92672">==</span> dC) {<span style="color:#75715e">//只有一列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> uR; i <span style="color:#f92672">&lt;=</span> dR; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>			cout <span style="color:#f92672">&lt;&lt;</span> a[i][uC] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> {<span style="color:#75715e">//打印四条边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> uC; i <span style="color:#f92672">&lt;</span> dC; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>			cout <span style="color:#f92672">&lt;&lt;</span> a[uR][i] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> uR; i <span style="color:#f92672">&lt;</span> dR; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>			cout <span style="color:#f92672">&lt;&lt;</span> a[i][dC] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> dC; i <span style="color:#f92672">&gt;</span> uC; <span style="color:#f92672">--</span>i)
</span></span><span style="display:flex;"><span>			cout <span style="color:#f92672">&lt;&lt;</span> a[dR][i] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> dR; i <span style="color:#f92672">&gt;</span> uR; <span style="color:#f92672">--</span>i)
</span></span><span style="display:flex;"><span>			cout <span style="color:#f92672">&lt;&lt;</span> a[i][uC] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">LoopPrint</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">**</span> a, <span style="color:#66d9ef">int</span> height, <span style="color:#66d9ef">int</span> width) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> uR <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, uC <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, dR <span style="color:#f92672">=</span> height <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, dC <span style="color:#f92672">=</span> width <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (uR <span style="color:#f92672">&lt;=</span> dR <span style="color:#f92672">&amp;&amp;</span> uC <span style="color:#f92672">&lt;=</span> dC) 
</span></span><span style="display:flex;"><span>		PrintNum(a, uR<span style="color:#f92672">++</span>, uC<span style="color:#f92672">++</span>, dR<span style="color:#f92672">--</span>, dC<span style="color:#f92672">--</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="正方形矩阵旋转90度-额外空间o1">正方形矩阵旋转90度 额外空间O(1)</h3>
<p>样例矩阵</p>
<p>输入    1 2 3                     输出     7 4 1</p>
<p>​            4 5 6                                 8 5 2</p>
<p>​            7 8 9                                 9 6 3</p>
<p>用转圈打印的方法，一次处理外边的一层，每次交换每条边上的四个数，递归进去。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">SwapLoop</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">**</span> a, <span style="color:#66d9ef">int</span> uR, <span style="color:#66d9ef">int</span> dR) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> uR; i <span style="color:#f92672">&lt;</span> dR; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> a[uR][i];
</span></span><span style="display:flex;"><span>		a[uR][i] <span style="color:#f92672">=</span> a[dR <span style="color:#f92672">+</span> uR <span style="color:#f92672">-</span> i][uR];
</span></span><span style="display:flex;"><span>		a[dR <span style="color:#f92672">+</span> uR <span style="color:#f92672">-</span> i][uR] <span style="color:#f92672">=</span> a[dR][dR <span style="color:#f92672">+</span> uR <span style="color:#f92672">-</span> i];
</span></span><span style="display:flex;"><span>		a[dR][dR <span style="color:#f92672">+</span> uR <span style="color:#f92672">-</span> i] <span style="color:#f92672">=</span> a[i][dR];
</span></span><span style="display:flex;"><span>		a[i][dR] <span style="color:#f92672">=</span> temp;<span style="color:#75715e">//交换四条边上对应位置的四个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rotateMatrix</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">**</span> a, <span style="color:#66d9ef">int</span> length) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> uR <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, dR <span style="color:#f92672">=</span> length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (uR <span style="color:#f92672">&lt;=</span> dR)
</span></span><span style="display:flex;"><span>		SwapLoop(a, uR<span style="color:#f92672">++</span>, dR<span style="color:#f92672">--</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="蛇形打印矩阵----额外空间o1">蛇形打印矩阵    额外空间O(1)</h3>
<p>输入    1 2 3                     输出    1 2 4 7 5 3 6 8 9</p>
<p>​            4 5 6</p>
<p>​            7 8 9</p>
<p>斜着一列一列打印，用bool变量表示从左下开始打印还是从右上开始打印。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PrintNum</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">**</span> a, <span style="color:#66d9ef">int</span> uR, <span style="color:#66d9ef">int</span> uC, <span style="color:#66d9ef">int</span> dR, <span style="color:#66d9ef">int</span> dC, <span style="color:#66d9ef">bool</span> isleft) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//isleft真从左下角开始打印，否则右上角开始打印
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (dR <span style="color:#f92672">&gt;=</span> uR <span style="color:#f92672">||</span> dC <span style="color:#f92672">&lt;=</span> uC) {
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> a[(isleft) <span style="color:#f92672">?</span> dR : uR][(isleft) <span style="color:#f92672">?</span> dC : uC] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (isleft) {
</span></span><span style="display:flex;"><span>			dR<span style="color:#f92672">--</span>; dC<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			uR<span style="color:#f92672">++</span>; uC<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">SnakePrint</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">**</span> a, <span style="color:#66d9ef">int</span> height, <span style="color:#66d9ef">int</span> width) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> isleft <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> uR <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, uC <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, dR <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, dC <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> height <span style="color:#f92672">+</span> width; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>		PrintNum(a, uR, uC, dR, dC, isleft);<span style="color:#75715e">//打印斜着的一列数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		uR <span style="color:#f92672">+=</span> (i <span style="color:#f92672">&lt;</span> width) <span style="color:#f92672">?</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		uC <span style="color:#f92672">+=</span> (i <span style="color:#f92672">&lt;</span> width) <span style="color:#f92672">?</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		dR <span style="color:#f92672">+=</span> (i <span style="color:#f92672">&lt;</span> height) <span style="color:#f92672">?</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		dC <span style="color:#f92672">+=</span> (i <span style="color:#f92672">&lt;</span> height) <span style="color:#f92672">?</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		isleft <span style="color:#f92672">=</span> <span style="color:#f92672">!</span>isleft;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="矩阵找数--时间omn">矩阵找数  时间O(M+N)</h3>
<p>给定一个矩阵行列均有序，线性时间内找数，找到返回true，否则返回false</p>
<p>输入    1 2 3          4              输出    true</p>
<p>​            4 5 6</p>
<p>​            7 8 9</p>
<p>从矩阵右上角开始倒着找</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">findmin</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">**</span> a, <span style="color:#66d9ef">int</span> height, <span style="color:#66d9ef">int</span> width, <span style="color:#66d9ef">int</span> num) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> width <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>j) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (a[<span style="color:#ae81ff">0</span>][j] <span style="color:#f92672">==</span> num)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (a[<span style="color:#ae81ff">0</span>][j] <span style="color:#f92672">&gt;</span> num)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> height; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (a[i][j] <span style="color:#f92672">==</span> num)
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (a[i][j] <span style="color:#f92672">&lt;</span> num)
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="part-4--链表问题">Part 4  链表问题</h2>
<h3 id="单链表回文">单链表回文</h3>
<ol>
<li>用一个辅助栈，遍历一个链表，每个数进栈，之后再遍历一次链表，把栈倒出来比对。时间O(N)，空间O(N)</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isPalindrome</span>(node<span style="color:#f92672">*</span> head) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(head<span style="color:#f92672">==</span>NULL<span style="color:#f92672">||</span>head<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">==</span>NULL)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>	stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> s;
</span></span><span style="display:flex;"><span>	node<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (p <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>		s.push(p<span style="color:#f92672">-&gt;</span>data);
</span></span><span style="display:flex;"><span>		p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	p <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (p <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> s.top();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (temp <span style="color:#f92672">!=</span> p<span style="color:#f92672">-&gt;</span>data)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			s.pop();
</span></span><span style="display:flex;"><span>			p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="2">
<li>要判断是不是回文，不用全部比较，只需要比较前半段和后半段。首先通过快慢指针，一个指针一次遍历一个结点，一个结点一次遍历两个结点，通过慢指针确定链表中间结点。将中间结点之后链表逆置，然后两边都向中间遍历，判断回文。判断结束，恢复逆置链表。时间O(N)，空间O(1)</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isPalindrome</span>(node<span style="color:#f92672">*</span> head) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (head <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> head<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>	node<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> head, <span style="color:#f92672">*</span> q <span style="color:#f92672">=</span> head;<span style="color:#75715e">//p每次走一个，q每次走两个
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> (q<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> q<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>		p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next; q <span style="color:#f92672">=</span> q<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	q <span style="color:#f92672">=</span> p;
</span></span><span style="display:flex;"><span>	node<span style="color:#f92672">*</span> front <span style="color:#f92672">=</span> NULL, <span style="color:#f92672">*</span> back;<span style="color:#75715e">//front指向当前结点前一个，back指向后一个
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> (q <span style="color:#f92672">!=</span> NULL) {<span style="color:#75715e">//后半部分链表逆置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		back <span style="color:#f92672">=</span> q<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>		q<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> front;
</span></span><span style="display:flex;"><span>		front <span style="color:#f92672">=</span> q;<span style="color:#75715e">//front停在最后一个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		q <span style="color:#f92672">=</span> back;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	q <span style="color:#f92672">=</span> head, back <span style="color:#f92672">=</span> front;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> ans <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (q <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">||</span> back <span style="color:#f92672">!=</span> NULL) {<span style="color:#75715e">//从前到后，从后到前比对
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (q<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">!=</span> back<span style="color:#f92672">-&gt;</span>data) {
</span></span><span style="display:flex;"><span>			ans <span style="color:#f92672">=</span> false; <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		}			
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			q <span style="color:#f92672">=</span> q<span style="color:#f92672">-&gt;</span>next; back <span style="color:#f92672">=</span> back<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	q <span style="color:#f92672">=</span> front; front <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (q <span style="color:#f92672">!=</span> NULL) {<span style="color:#75715e">//恢复后半部分逆置的链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		back <span style="color:#f92672">=</span> q<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>		q<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> front;
</span></span><span style="display:flex;"><span>		front <span style="color:#f92672">=</span> q;
</span></span><span style="display:flex;"><span>		q <span style="color:#f92672">=</span> back;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="链表荷兰国旗">链表荷兰国旗</h3>
<p>单链表给值，小于放左边，等于放中间，大于放右边。要求小于等于大于部分均和原链表中的数据顺序保持一致。eg.9-&gt;0-&gt;4-&gt;5-&gt;1，num=3，输出，0-&gt;1-&gt;9-&gt;4-&gt;5。其次空间O(1)，时间O(N)，不能把数据倒进数组然后荷兰国旗，没有稳定性。</p>
<p>分析：建6个变量，分别为小于等于大于区域的头尾，遍历链表，小于就连到小于区域，等于大于同理，最后把小于等于大于区域连起来即可。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">NetherlandLinkList</span>(node<span style="color:#f92672">*</span> <span style="color:#f92672">&amp;</span>head, <span style="color:#66d9ef">int</span> num) {
</span></span><span style="display:flex;"><span>	node<span style="color:#f92672">*</span> lessStart <span style="color:#f92672">=</span> NULL, <span style="color:#f92672">*</span> moreStart <span style="color:#f92672">=</span> NULL, <span style="color:#f92672">*</span> equalStart <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	node<span style="color:#f92672">*</span> lessEnd <span style="color:#f92672">=</span> NULL, <span style="color:#f92672">*</span> moreEnd <span style="color:#f92672">=</span> NULL, <span style="color:#f92672">*</span> equalEnd <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	node<span style="color:#f92672">*</span> temp;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (head <span style="color:#f92672">!=</span> NULL) {<span style="color:#75715e">//把当前链表拆成三段
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		temp <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>		head<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (head<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">==</span> num) {<span style="color:#75715e">//等于区域
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (equalStart <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>				equalStart <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>				equalEnd <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>				equalEnd<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>				equalEnd <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (head<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;</span> num) {<span style="color:#75715e">//小于区域
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (lessStart <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>				lessStart <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>				lessEnd <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>				lessEnd<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>				lessEnd <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (moreStart <span style="color:#f92672">==</span> NULL) {<span style="color:#75715e">//大于区域
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				moreStart <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>				moreEnd <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>				moreEnd<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>				moreEnd <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		head <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (lessEnd <span style="color:#f92672">==</span> NULL) 
</span></span><span style="display:flex;"><span>		head <span style="color:#f92672">=</span> equalStart;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		head <span style="color:#f92672">=</span> lessStart;
</span></span><span style="display:flex;"><span>		lessEnd<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> equalStart;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (equalEnd <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>		lessEnd<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> moreStart;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		equalEnd<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> moreStart;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="单链表相交">单链表相交</h3>
<p>两个单链表长度M,N是否相交，相交返回表交点。链表可有环可无环。要求时间O(M+N)，空间O(1)</p>
<ol>
<li>
<p>检查两个链表是否含有环，有的话返回入环结点，没有返回NULL。这里有两种办法1）从头遍历，每个节点放进hashset里面，之后每个结点进之前看看hashset里面有没有当前结点，有说明有环，返回第一个重复的结点；如果遍历到了NULL说明没有环。2）快慢指针，如果快指针走到NULL，无环；如果快指针慢指针重合，有环，快指针从头开始，慢指针从相遇位置开始一次一个结点，再次相遇地点即为入环结点。易证明：假设快指针没单位时间走2，慢指针每单位时间走1，非环部分长度R，环部分长度L，则快慢指针相遇，快指针比满指针多走k圈，慢指针在环上走的路程为kL-R，说明距离第k圈还差R距离，这时候每次一个结点，快慢指针会在入环结点相遇。</p>
<p>$$
2t  =t+kL\
t  =kL\
s=t-R=kL-R
$$</p>
</li>
<li>
<p>如果一个有环，一个无环，不相交。如果两个都无环，两个都遍历到底，看看最后一个结点是否相同，相同即相交，不同不相交。如果两个都有环，看两个链表入环结点是否相同，相同就是有环1，等同于无环2，终点为入环节点；入环接待你不同，在1的环里面循环一圈有没有2的入环结点，没有就是有环3，有就是有环2</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>node<span style="color:#f92672">*</span> <span style="color:#a6e22e">getLoopNode</span>(node<span style="color:#f92672">*</span> head) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (head <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> head<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> head<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NULL;		<span style="color:#75715e">//至少需要三个结点才能成环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	node<span style="color:#f92672">*</span> fast <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next, <span style="color:#f92672">*</span> slow <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (fast <span style="color:#f92672">!=</span> slow <span style="color:#f92672">&amp;&amp;</span> fast<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> fast<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>		fast <span style="color:#f92672">=</span> fast<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next; 
</span></span><span style="display:flex;"><span>		slow <span style="color:#f92672">=</span> slow<span style="color:#f92672">-&gt;</span>next;<span style="color:#f92672">/</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (fast<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> fast<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>	fast <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (slow <span style="color:#f92672">!=</span> fast) {
</span></span><span style="display:flex;"><span>		fast <span style="color:#f92672">=</span> fast<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>		slow <span style="color:#f92672">=</span> slow<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> fast;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>node<span style="color:#f92672">*</span> <span style="color:#a6e22e">noLoop</span>(node<span style="color:#f92672">*</span> head1, node<span style="color:#f92672">*</span> head2) {
</span></span><span style="display:flex;"><span>	node<span style="color:#f92672">*</span> n1 <span style="color:#f92672">=</span> head1, <span style="color:#f92672">*</span> n2 <span style="color:#f92672">=</span> head2;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> length1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, length2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (n1<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> n2<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">++</span>length1; <span style="color:#f92672">++</span>length2;
</span></span><span style="display:flex;"><span>		n1 <span style="color:#f92672">=</span> n1<span style="color:#f92672">-&gt;</span>next; n2 <span style="color:#f92672">=</span> n2<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (n1<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">++</span>length1; n1 <span style="color:#f92672">=</span> n1<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (n2<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">++</span>length2; n2 <span style="color:#f92672">=</span> n2<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (n1 <span style="color:#f92672">!=</span> n2)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	n1 <span style="color:#f92672">=</span> (length1 <span style="color:#f92672">&gt;</span> length2) <span style="color:#f92672">?</span> head1 : head2;
</span></span><span style="display:flex;"><span>	n2 <span style="color:#f92672">=</span> (length1 <span style="color:#f92672">&gt;</span> length2) <span style="color:#f92672">?</span> head2 : head1;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (count <span style="color:#f92672">&lt;</span> abs(length1 <span style="color:#f92672">-</span> length2)) {
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">++</span>count; n1 <span style="color:#f92672">=</span> n1<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (n1 <span style="color:#f92672">!=</span> n2) {
</span></span><span style="display:flex;"><span>		n1 <span style="color:#f92672">=</span> n1<span style="color:#f92672">-&gt;</span>next; n2 <span style="color:#f92672">=</span> n2<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> n1;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>node<span style="color:#f92672">*</span> <span style="color:#a6e22e">bothLoop</span>(node<span style="color:#f92672">*</span> head1, node<span style="color:#f92672">*</span> loopNode1, node<span style="color:#f92672">*</span> head2, node<span style="color:#f92672">*</span> loopNode2) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (loopNode1 <span style="color:#f92672">!=</span> loopNode2) {
</span></span><span style="display:flex;"><span>		node<span style="color:#f92672">*</span> n <span style="color:#f92672">=</span> loopNode1<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> (n <span style="color:#f92672">!=</span> loopNode1) {<span style="color:#75715e">//在1的环里面转一圈，没有2的入环点12不交，否则返回1入环点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> (n <span style="color:#f92672">==</span> loopNode2)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> loopNode1;
</span></span><span style="display:flex;"><span>			n <span style="color:#f92672">=</span> n<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	node<span style="color:#f92672">*</span> n1 <span style="color:#f92672">=</span> head1, <span style="color:#f92672">*</span> n2 <span style="color:#f92672">=</span> head2;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> length1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, length2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (n1 <span style="color:#f92672">!=</span> loopNode1 <span style="color:#f92672">&amp;&amp;</span> n2 <span style="color:#f92672">!=</span> loopNode1) {
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">++</span>length1; <span style="color:#f92672">++</span>length2;
</span></span><span style="display:flex;"><span>		n1 <span style="color:#f92672">=</span> n1<span style="color:#f92672">-&gt;</span>next; n2 <span style="color:#f92672">=</span> n2<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (n1 <span style="color:#f92672">!=</span> loopNode1) {
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">++</span>length1; n1 <span style="color:#f92672">=</span> n1<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (n2 <span style="color:#f92672">!=</span> loopNode1) {
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">++</span>length2; n2 <span style="color:#f92672">=</span> n2<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	n1 <span style="color:#f92672">=</span> (length1 <span style="color:#f92672">&gt;</span> length2) <span style="color:#f92672">?</span> head1 : head2;
</span></span><span style="display:flex;"><span>	n2 <span style="color:#f92672">=</span> (length1 <span style="color:#f92672">&gt;</span> length2) <span style="color:#f92672">?</span> head2 : head1;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (count <span style="color:#f92672">&lt;</span> abs(length1 <span style="color:#f92672">-</span> length2)) {
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">++</span>count; n1 <span style="color:#f92672">=</span> n1<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (n1 <span style="color:#f92672">!=</span> n2) {
</span></span><span style="display:flex;"><span>		n1 <span style="color:#f92672">=</span> n1<span style="color:#f92672">-&gt;</span>next; n2 <span style="color:#f92672">=</span> n2<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> n1;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>node<span style="color:#f92672">*</span> <span style="color:#a6e22e">getIntersectNode</span>(node<span style="color:#f92672">*</span> head1, node<span style="color:#f92672">*</span> head2) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (head1 <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> head2 <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>	node<span style="color:#f92672">*</span> loop1 <span style="color:#f92672">=</span> getLoopNode(head1);
</span></span><span style="display:flex;"><span>	node<span style="color:#f92672">*</span> loop2 <span style="color:#f92672">=</span> getLoopNode(head2);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (loop1 <span style="color:#f92672">==</span> NULL <span style="color:#f92672">&amp;&amp;</span> loop2 <span style="color:#f92672">==</span> NULL) 
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> noLoop(head1, head2);<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (loop1 <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> loop2 <span style="color:#f92672">!=</span> NULL) 
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> bothLoop(head1, loop1, head2, loop2);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> NULL;<span style="color:#75715e">//一个无环一个有环无交点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h1 id="第四讲">第四讲</h1>
<h2 id="part-1--树的非递归遍历">Part 1  树的非递归遍历</h2>
<h3 id="前序">前序</h3>
<p>用栈存结点，每个头结点直接输出，非空情况下，右孩子先进栈，左孩子再进栈，这样取出来才是先左后右。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">preOrderUnRecur</span>(BiTree T) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (T <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	stack<span style="color:#f92672">&lt;</span>BiTNode<span style="color:#f92672">&gt;</span> a;
</span></span><span style="display:flex;"><span>	a.push(<span style="color:#f92672">*</span>T);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>a.empty()) {
</span></span><span style="display:flex;"><span>		BiTNode<span style="color:#f92672">*</span> temp <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>(a.top());
</span></span><span style="display:flex;"><span>		a.pop();
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> temp<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (temp<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">!=</span> NULL)
</span></span><span style="display:flex;"><span>			a.push(<span style="color:#f92672">*</span>temp<span style="color:#f92672">-&gt;</span>rchild);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (temp<span style="color:#f92672">-&gt;</span>lchild <span style="color:#f92672">!=</span> NULL)
</span></span><span style="display:flex;"><span>			a.push(<span style="color:#f92672">*</span>temp<span style="color:#f92672">-&gt;</span>lchild);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="中序">中序</h3>
<p>一直把左孩子进栈到底，发现左孩子为空，从栈里面取一个输出然后递归右孩子。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">inOrderUnRecur</span>(BiTree T) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (T <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	stack<span style="color:#f92672">&lt;</span>BiTNode<span style="color:#f92672">&gt;</span> s;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>s.empty() <span style="color:#f92672">||</span> T <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (T <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>			s.push(<span style="color:#f92672">*</span>T);
</span></span><span style="display:flex;"><span>			T <span style="color:#f92672">=</span> T<span style="color:#f92672">-&gt;</span>lchild;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			BiTNode<span style="color:#f92672">*</span> temp <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>(s.top());
</span></span><span style="display:flex;"><span>			s.pop();
</span></span><span style="display:flex;"><span>			cout <span style="color:#f92672">&lt;&lt;</span> temp<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>			T <span style="color:#f92672">=</span> temp<span style="color:#f92672">-&gt;</span>rchild;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="后序">后序</h3>
<p>后序为左右中，先序为中左右，先序改变左右孩子进栈顺序即可改为中右左，把先序即将输出的数据放进辅助栈，结束以后依次打印栈里面的内容即可。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">posOrderUnRecur</span>(BiTree T) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (T <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	stack<span style="color:#f92672">&lt;</span>BiTNode<span style="color:#f92672">&gt;</span> a, help;
</span></span><span style="display:flex;"><span>	a.push(<span style="color:#f92672">*</span>T);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>a.empty()) {
</span></span><span style="display:flex;"><span>		BiTNode<span style="color:#f92672">*</span> temp <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>(a.top());
</span></span><span style="display:flex;"><span>		a.pop();
</span></span><span style="display:flex;"><span>		help.push(<span style="color:#f92672">*</span>temp);<span style="color:#75715e">//先放进辅助栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (temp<span style="color:#f92672">-&gt;</span>lchild <span style="color:#f92672">!=</span> NULL)<span style="color:#75715e">//左子先进保证中右左
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			a.push(<span style="color:#f92672">*</span>temp<span style="color:#f92672">-&gt;</span>lchild);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (temp<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">!=</span> NULL)
</span></span><span style="display:flex;"><span>			a.push(<span style="color:#f92672">*</span>temp<span style="color:#f92672">-&gt;</span>rchild);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>help.empty()) {
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> help.top().data <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>		help.pop();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="part-2--增加父亲结点求后继">Part 2  增加父亲结点求后继</h2>
<p>二叉树结构增加parent指针，求中序后继结点。</p>
<ol>
<li>该结点有右孩子，找右子树最左边的结点</li>
<li>该结点没有有孩子，通过parent指针往树的上边找，找某个父亲结点作为其父亲的左孩子，其父亲即为所求</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>BiTNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">getNextNode_InOrder</span>(BiTree T, BiTNode n) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (n.rchild <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		BiTNode<span style="color:#f92672">*</span> parent <span style="color:#f92672">=</span> n.parent, <span style="color:#f92672">*</span> child <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>n;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> (child <span style="color:#f92672">!=</span> parent<span style="color:#f92672">-&gt;</span>lchild <span style="color:#f92672">&amp;&amp;</span> parent <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//parent==NULL 说明遍历到树顶，没找到作为左孩子的父亲，说明给节点没有后继返回NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			child <span style="color:#f92672">=</span> parent;
</span></span><span style="display:flex;"><span>			parent <span style="color:#f92672">=</span> parent<span style="color:#f92672">-&gt;</span>parent;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> parent;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		BiTNode<span style="color:#f92672">*</span> temp <span style="color:#f92672">=</span> n.rchild;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> (temp<span style="color:#f92672">-&gt;</span>lchild <span style="color:#f92672">!=</span> NULL)
</span></span><span style="display:flex;"><span>			temp <span style="color:#f92672">=</span> temp<span style="color:#f92672">-&gt;</span>lchild;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> temp;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="part-3--判断树的结构">Part 3  判断树的结构</h2>
<h3 id="判断平衡二叉树">判断平衡二叉树</h3>
<p>递归左右孩子，递归返回两个值，一个是子树的高度，另一个是子树是否平衡，通过返回值判断平衡</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">childTreeInfo</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> isbanlance;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> height;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>childTreeInfo <span style="color:#a6e22e">recurProcess</span>(BiTree T) {
</span></span><span style="display:flex;"><span>	childTreeInfo recordleft, recordright, temp;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (T <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>		temp.isbanlance <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>		temp.height <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> temp;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	recordleft <span style="color:#f92672">=</span> recurProcess(T<span style="color:#f92672">-&gt;</span>lchild);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (recordleft.isbanlance <span style="color:#f92672">==</span> false) {
</span></span><span style="display:flex;"><span>		temp.isbanlance <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>		temp.height <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> temp;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	recordright <span style="color:#f92672">=</span> recurProcess(T<span style="color:#f92672">-&gt;</span>rchild);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (recordright.isbanlance <span style="color:#f92672">==</span> false) {
</span></span><span style="display:flex;"><span>		temp.isbanlance <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>		temp.height <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> temp;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (abs(recordleft.height <span style="color:#f92672">-</span> recordright.height) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>		temp.isbanlance <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>		temp.height <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> temp;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		temp.isbanlance <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>		temp.height <span style="color:#f92672">=</span> max(recordleft.height, recordright.height) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> temp;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isBlanceTree</span>(BiTree T) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> recurProcess(T).isbanlance;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="判断二叉排序树">判断二叉排序树</h3>
<ol>
<li>只需递归左右孩子，看左是不是小于根，右是不是大于根</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isBST</span>(BiTree T) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (T <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> ((T<span style="color:#f92672">-&gt;</span>lchild <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> T<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;</span> T<span style="color:#f92672">-&gt;</span>lchild<span style="color:#f92672">-&gt;</span>data) <span style="color:#f92672">||</span> (T<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;</span> T<span style="color:#f92672">-&gt;</span>rchild<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&amp;&amp;</span> T<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">!=</span> NULL))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (isBST(T<span style="color:#f92672">-&gt;</span>lchild) <span style="color:#f92672">&amp;&amp;</span> isBST(T<span style="color:#f92672">-&gt;</span>rchild))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="2">
<li>非递归中序遍历，只要不是升序，返回错误</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isBST</span>(BiTree T) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (T <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	stack<span style="color:#f92672">&lt;</span>BiTNode<span style="color:#f92672">&gt;</span> s;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> treenum <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">999999999</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>s.empty() <span style="color:#f92672">||</span> T <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (T <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>			s.push(<span style="color:#f92672">*</span>T);
</span></span><span style="display:flex;"><span>			T <span style="color:#f92672">=</span> T<span style="color:#f92672">-&gt;</span>lchild;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			BiTNode<span style="color:#f92672">*</span> temp <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>(s.top());
</span></span><span style="display:flex;"><span>			s.pop();
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (treenum <span style="color:#f92672">&lt;</span> temp<span style="color:#f92672">-&gt;</span>data)
</span></span><span style="display:flex;"><span>				treenum <span style="color:#f92672">=</span> temp<span style="color:#f92672">-&gt;</span>data;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>			T <span style="color:#f92672">=</span> temp<span style="color:#f92672">-&gt;</span>rchild;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="判断完全二叉树">判断完全二叉树</h3>
<p>层次遍历，三种情况：1）左右孩子都有，继续遍历。2）左孩子没有，右孩子有，不是完全二叉树。3）左孩子有右孩子没有或者左右孩子都没有，则接下来遍历的结点都是叶子结点，否则不是。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isCST</span>(BiTree T) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> leaf <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>	queue<span style="color:#f92672">&lt;</span>BiTNode<span style="color:#f92672">&gt;</span> help;
</span></span><span style="display:flex;"><span>	help.push(<span style="color:#f92672">*</span>T);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>help.empty()) {
</span></span><span style="display:flex;"><span>		BiTNode<span style="color:#f92672">*</span> temp <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>help.front();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (temp<span style="color:#f92672">-&gt;</span>lchild <span style="color:#f92672">==</span> NULL <span style="color:#f92672">&amp;&amp;</span> temp<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">!=</span> NULL)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (leaf <span style="color:#f92672">&amp;&amp;</span> (temp<span style="color:#f92672">-&gt;</span>lchild <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">||</span> temp<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">!=</span> NULL))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (temp<span style="color:#f92672">-&gt;</span>lchild <span style="color:#f92672">!=</span> NULL)
</span></span><span style="display:flex;"><span>			help.push(<span style="color:#f92672">*</span>temp<span style="color:#f92672">-&gt;</span>lchild);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (temp<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">!=</span> NULL)
</span></span><span style="display:flex;"><span>			help.push(<span style="color:#f92672">*</span>temp<span style="color:#f92672">-&gt;</span>rchild);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>			leaf <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="part-4--完全二叉树求结点数">Part 4  完全二叉树求结点数</h2>
<p>时间复杂度小于<code>O(N)</code></p>
<p>利用完全二叉树的特点，遍历最左边结点可以求出二叉树的深度d1，接下来求头结点右子树左边结点的深度d2</p>
<ol>
<li>d1=d2+1，说明头结点的左子树满二叉树，根据高度可直接计算节点数，2^d1^-1+1(头结点)，之后递归右子树</li>
<li>d1!=d2+1，说明头结点的右子树满二叉树，根据高度计算出结点数2^d2^-1+1(头结点)，之后递归左子树</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">CBTDepth</span>(BiTree T) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (T <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (T <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">++</span>length;
</span></span><span style="display:flex;"><span>		T <span style="color:#f92672">=</span> T<span style="color:#f92672">-&gt;</span>lchild;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> length;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">nodeNumCBT</span>(BiTree T) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (T <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> depth <span style="color:#f92672">=</span> CBTDepth(T);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> rChildDepth <span style="color:#f92672">=</span> CBTDepth(T<span style="color:#f92672">-&gt;</span>rchild);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (rChildDepth <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> depth) {
</span></span><span style="display:flex;"><span>		count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> (depth <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>		count <span style="color:#f92672">+=</span> nodeNumCBT(T<span style="color:#f92672">-&gt;</span>rchild);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> (depth <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>		count <span style="color:#f92672">+=</span> nodeNumCBT(T<span style="color:#f92672">-&gt;</span>lchild);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> count;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="第五讲">第五讲</h1>
<h2 id="part-1--哈希函数与哈希表">Part 1  哈希函数与哈希表</h2>
<p>经典哈希函数性质：</p>
<ol>
<li>输入域无穷，输出域有穷</li>
<li>输入相同，输出一定相同</li>
<li>不同输入可能对应相同输出</li>
<li>输入量足够多时，输出会在值域内均匀分布，非常重要</li>
<li>大样本经过哈希函数计算的值模m之后得到的值在[0-m]内仍然均匀分布</li>
<li>哈希函数之间相互独立，线性组合后仍然为哈希函数。哈希函数得出的哈希值每一位相互独立</li>
</ol>
<p>经典哈希表，表每个位置都是一个单链表，增删改查时间O(1)</p>
<p>经典哈希的应用：处理大数据问题。现在有100TB字符串文件，把它输出所有重复，有m台机器来处理，这时候应该如何分配嘞？利用哈希函数计算然后模m，值是多少就用哪台机器处理。因为哈希函数具有值域均匀分布的特点，所以m台机器的任务量基本相同保证了负载平衡。因为输入相同，输出相同，所以相同的字符串哈希值一定相同，相同的字符串一定由同一台机器处理，这样就解决了重复问题。如果每台机器任务量仍然过大，可以继续哈希，继续缩小任务量。</p>
<p><strong>小练习</strong>：设计RandomPool结构，insert(key)，delete(key)，getRandom(key)，时间复杂度要求O(1)，getRandom等概率返回结构中的任何一个key
分析：这道题主要考虑如何等概率返回，insert的时候加一个时间戳，记录个数size，getRandom的时候利用产生随机数0-size，用hashmap，但是需要返回key，产生随机数是value，所以返回去找时间就不是O(1)了，所以要再建一个辅助表，size作为key，输入作为value，这样随机数之后，O(1)就能找到相应的key。接下来考虑delete，删除一个后，0-size中间会有洞，就不能等概率了，所以把最后一个key换到删除的key处，size&ndash;，保证结构稳定性。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RandomPool</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	unordered_map<span style="color:#f92672">&lt;</span>string, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> mapMain;
</span></span><span style="display:flex;"><span>	unordered_map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, string<span style="color:#f92672">&gt;</span> mapHelp;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> size;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	RandomPool() {
</span></span><span style="display:flex;"><span>		size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(string key) {
</span></span><span style="display:flex;"><span>		mapMain.insert({ key, size });
</span></span><span style="display:flex;"><span>		mapHelp.insert({ size, key });
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">++</span>size;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">deleteKey</span>(string key) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (size <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (mapMain.find(key) <span style="color:#f92672">!=</span> mapMain.end()) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> deleteIndex <span style="color:#f92672">=</span> mapMain.find(key)<span style="color:#f92672">-&gt;</span>second;
</span></span><span style="display:flex;"><span>			string lastString <span style="color:#f92672">=</span> mapHelp.find(size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)<span style="color:#f92672">-&gt;</span>second;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			mapMain[lastString] <span style="color:#f92672">=</span> deleteIndex; 
</span></span><span style="display:flex;"><span>			mapMain.erase(key);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			mapHelp[deleteIndex] <span style="color:#f92672">=</span> lastString;
</span></span><span style="display:flex;"><span>			mapHelp.erase(<span style="color:#f92672">--</span>size);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	string <span style="color:#a6e22e">getRandom</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (size <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;No string&#34;</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> rand() <span style="color:#f92672">%</span> size;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> mapHelp.find(index)<span style="color:#f92672">-&gt;</span>second;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>() {
</span></span><span style="display:flex;"><span>		unordered_map <span style="color:#f92672">&lt;</span>string, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator it1 <span style="color:#f92672">=</span> mapMain.begin();
</span></span><span style="display:flex;"><span>		unordered_map <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, string<span style="color:#f92672">&gt;::</span>iterator it2 <span style="color:#f92672">=</span> mapHelp.begin();
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;mapMain:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (; it1 <span style="color:#f92672">!=</span> mapMain.end(); <span style="color:#f92672">++</span>it1)
</span></span><span style="display:flex;"><span>			cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;&lt;&#34;</span> <span style="color:#f92672">&lt;&lt;</span> it1<span style="color:#f92672">-&gt;</span>first <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;,&#34;</span> <span style="color:#f92672">&lt;&lt;</span> it1<span style="color:#f92672">-&gt;</span>second <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;&gt;&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;mapHelp:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (; it2 <span style="color:#f92672">!=</span> mapHelp.end(); <span style="color:#f92672">++</span>it2)
</span></span><span style="display:flex;"><span>			cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;&lt;&#34;</span> <span style="color:#f92672">&lt;&lt;</span> it2<span style="color:#f92672">-&gt;</span>first <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;,&#34;</span> <span style="color:#f92672">&lt;&lt;</span> it2<span style="color:#f92672">-&gt;</span>second <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;&gt;&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> size <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><hr>
<h2 id="part-2--布隆过滤器">Part 2  布隆过滤器</h2>
<p>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构，特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p>
<p>举个例子，现在搜索引擎有100亿个url黑名单，总共6400G空间，现在我们怎么存储黑名单，保证增删改查时间O(1)，哈希表符合但是需要的空间太大了。这时候布隆过滤器就出现了。
布隆过滤器是bit数组，每一位值为0/1，bit数组用int[1000]（表示32000个bit的bit数组），long long[1000][1000]（表示64000000bit的bit数组，假设准备一个<strong>长度m</strong>的bit数组，初始值全为0。接下来准备k个哈希函数相互独立，每个url通过<strong>k个哈希函数</strong>计算哈希值模m，值是多少，bit数组相应位置置1。这样结束以后，得到的bit数组即为布隆过滤器，以后来一个url就k次哈希看看这些bit位上是不是已经置1了，有一个没有置1，说明它不是黑名单。当然全部k个哈希都置1，也不能说明这个url就是黑名单，只能说可能，这就是布隆过滤器的失误，有个<strong>失误率即为p</strong>。<strong>宁可错杀一千也不放过一个</strong></p>
<p><img src="https://raw.githubusercontent.com/xiaoqiao12138/PicBackUp/main/img/20210701153247.jpg" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/xiaoqiao12138/PicBackUp/main/img/20210701153252.jpg" alt="img"></p>
<p>接下来介绍，m、p、k等值怎么选，n表示样本量
$$
m=-\frac{nlnp}{(ln2)^2}\
k=ln2\frac{m}{n}\
p=(1-e^{-\frac{nk}{m}})^k
$$
经过这样的计算，原来6400G的空间现在只需要16G，布隆过滤器十分实用。</p>
<hr>
<h2 id="part-3--一致性哈希">Part 3  一致性哈希</h2>
<p>一致性哈希实际上是想解决增加删除等工作负载平衡的问题。
首先一堆任务有m台机器处理，通过哈希函数我们能做到任务均匀分布到每台机器。但是这时候出现了一个问题，如果有一台机器坏了或者要增加一台机器，那么之前所有已经计算好的哈希值都要重新计算一次，这就增加了很多的工作量，所以引入一致性哈希。</p>
<p>引入<strong>环形Hash空间</strong>：按照常用的hash算法来将对应的key哈希到一个具有2^32次方个桶的空间中，即0~(2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。如下图</p>
<p><img src="https://raw.githubusercontent.com/xiaoqiao12138/PicBackUp/main/img/20210701153255.png" alt="img"></p>
<p><strong>把数据通过一定的hash算法处理后映射到环上</strong>：将object1、object2、object3、object4四个对象通过特定的Hash函数计算出对应的key值，然后散列到Hash环上。如下图：</p>
<p><img src="https://raw.githubusercontent.com/xiaoqiao12138/PicBackUp/main/img/20210701153259.png" alt="img"></p>
<p><strong>将机器通过hash算法映射到环上</strong>：在采用一致性哈希算法的分布式集群中将新的机器加入，其原理是通过使用与对象存储一样的Hash算法将机器也映射到环中（一般情况下对机器的hash计算是采用机器的IP或者机器唯一的别名作为输入值）假设现在有NODE1，NODE2，NODE3三台机器，通过Hash算法得到对应的KEY值，映射到环中</p>
<p><img src="https://raw.githubusercontent.com/xiaoqiao12138/PicBackUp/main/img/20210701153301.png" alt="img"></p>
<p>接下来，每个任务的哈希值去找顺时针方向上最小第一个机器哈希值，就实现了任务分配，增加减少机器，只需要再哈希环上去掉相应机器的哈希值，任务仍然按照顺时针去找机器。但是这样的话还存在问题，由于哈希的随机性，负载平衡不能保证了。每台机器不能保证把哈希环均分，无法保证负载平衡。</p>
<p><img src="https://img-blog.csdn.net/20140411001033656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3l3b3Nw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>一致性Hash算法引入了<strong>虚拟节点机制</strong>，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器IP或主机名的后面增加编号来实现。例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：任务哈希以后顺时针距离哪个虚拟节点近就根据虚拟节点的主机确定是哪个机器处理</p>
<!-- raw HTML omitted -->
<p>在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。</p>
<hr>
<h2 id="part-4--并查集">Part 4  并查集</h2>
<p>并查集 $Union-find Sets$ 是一种非常精巧而实用的数据结构，它主要用于处理一些<strong>不相交集合</strong>的合并问题。一些常见的用途有求连通子图、求最小生成树的 Kruskal 算法和求最近公共祖先 $Least Common Ancestors, LCA$等。</p>
<p>使用并查集时，首先会存在一组不相交的动态集合<strong>S={S~1~,S~2,~⋯,S~k~}</strong>，一般都会使用一个整数表示集合中的一个元素。每个集合可能包含一个或多个元素，并选出集合中的某个元素作为<strong>代表</strong>。每个集合中具体包含了哪些元素是不关心的，具体选择哪个元素作为代表一般也是不关心的。我们关心的是，对于给定的元素，可以很快的找到这个元素所在的集合（的代表），以及合并两个元素所在的集合，而且这些操作的时间复杂度都是<strong>常数级</strong>的。</p>
<p>并查集的基本操作有三个：</p>
<ol>
<li>$makeSet(s)$：建立一个新的并查集，其中包含 s 个单元素集合。</li>
<li>$unionSet(x, y)$：把元素 x 和元素 y 所在的集合合并，要求 x 和 y 所在的集合不相交，如果相交则不合并。</li>
<li>$findHead(x)$：找到元素 x 所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将它们各自的代表比较一下就可以了。</li>
</ol>
<p>并查集的实现原理也比较简单，就是使用树来表示集合，树的每个节点就表示集合中的一个元素，树根对应的元素就是该集合的代表。</p>
<p><img src="https://raw.githubusercontent.com/xiaoqiao12138/PicBackUp/main/img/20210701153320.png" alt="img"></p>
<p>图中有两棵树，分别对应两个集合，其中第一个集合为 <strong>{a,b,c,d}</strong>，代表元素是<strong>a</strong>；第二个集合为 <strong>{e,f,g}</strong>，代表元素是<strong>e</strong>。树的节点表示集合中的元素，指针表示指向父节点的指针，根节点的指针指向自己，表示其没有父节点。沿着每个节点的父节点不断向上查找，最终就可以找到该树的根节点，即该集合的代表元素。</p>
<p>$makeSet$ 要做的就是构造出如图 2 的森林，其中每个元素都是一个单元素集合，即父节点是其自身。</p>
<p><img src="https://raw.githubusercontent.com/xiaoqiao12138/PicBackUp/main/img/20210701153328.png" alt="img"></p>
<p>$find$ 如果每次都沿着父节点向上查找，那时间复杂度就是树的高度，完全不可能达到常数级。这里需要应用一种非常简单而有效的策略——路径压缩。路径压缩，就是在每次查找时，令查找路径上的每个节点都直接指向根节点。</p>
<p><img src="https://raw.githubusercontent.com/xiaoqiao12138/PicBackUp/main/img/20210701153332.png" alt="img"></p>
<p>合并操作 $unionSet$ ，并查集的合并也非常简单，就是将一个小的集合的树根指向大的集合的树根。</p>
<p><img src="https://raw.githubusercontent.com/xiaoqiao12138/PicBackUp/main/img/20210701153335.png" alt="img"></p>
<p>并查集的空间复杂度是 $O(n)$ 的。find 和 unionSet 操作都可以看成是常数级的，或者准确来说，在一个包含n个元素的并查集中，进行m次查找或合并操作，最坏情况下所需的时间为<strong>O(mα(n))</strong>，这里的<strong>α</strong>是 <a href="http://zh.wikipedia.org/wiki/%E9%98%BF%E5%85%8B%E6%9B%BC%E5%87%BD%E6%95%B0">Ackerman 函数</a>的某个反函数，在极大的范围内（比可观察到的宇宙中估计的原子数量还大很多）都可以认为是不大于 4 的。具体的时间复杂度分析，请参见《算法导论》的 21.4 节 带路径压缩的按秩合并的分析。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">unionFindSet</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	unordered_map<span style="color:#f92672">&lt;</span>Node, Node<span style="color:#f92672">&gt;</span> fathermap;<span style="color:#75715e">//key:child,value:father
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	unordered_map<span style="color:#f92672">&lt;</span>Node, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> sizemap;<span style="color:#75715e">//num of nodes in the set with the head of node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> makeSet(list<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">&gt;</span> l) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (Node node : l) {
</span></span><span style="display:flex;"><span>			fathermap.insert({ node,node });
</span></span><span style="display:flex;"><span>			sizemap.insert({ node,<span style="color:#ae81ff">1</span> });
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Node <span style="color:#a6e22e">findHeadUnRecur</span>(Node node) {
</span></span><span style="display:flex;"><span>		stack<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">&gt;</span> help;
</span></span><span style="display:flex;"><span>		Node father <span style="color:#f92672">=</span> fathermap.find(node)<span style="color:#f92672">-&gt;</span>second;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> (father <span style="color:#f92672">!=</span> node) {
</span></span><span style="display:flex;"><span>			help.push(node);
</span></span><span style="display:flex;"><span>			node <span style="color:#f92672">=</span> father;
</span></span><span style="display:flex;"><span>			father <span style="color:#f92672">=</span> fathermap.find(node)<span style="color:#f92672">-&gt;</span>second;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>help.empty()) {
</span></span><span style="display:flex;"><span>			Node temp <span style="color:#f92672">=</span> help.top();
</span></span><span style="display:flex;"><span>			help.pop();
</span></span><span style="display:flex;"><span>			fathermap[temp]<span style="color:#f92672">=</span>father;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> father;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Node <span style="color:#a6e22e">findHeadRecur</span>(Node node) {
</span></span><span style="display:flex;"><span>		Node father <span style="color:#f92672">=</span> fathermap.find(node)<span style="color:#f92672">-&gt;</span>second;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> (father <span style="color:#f92672">!=</span> node) {
</span></span><span style="display:flex;"><span>			father <span style="color:#f92672">=</span> findHeadRecur(father);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		fathermap[node]<span style="color:#f92672">=</span>father;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> father;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unionSet</span>(Node a, Node b) {
</span></span><span style="display:flex;"><span>		Node fatherA <span style="color:#f92672">=</span> findHeadUnRecur(a);
</span></span><span style="display:flex;"><span>		Node fatherB <span style="color:#f92672">=</span> findHeadUnRecur(b);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (fatherA <span style="color:#f92672">!=</span> fatherB) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> aSize <span style="color:#f92672">=</span> sizemap.find(a)<span style="color:#f92672">-&gt;</span>second;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> bSize <span style="color:#f92672">=</span> sizemap.find(b)<span style="color:#f92672">-&gt;</span>second;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (aSize<span style="color:#f92672">&gt;</span>bSize) {
</span></span><span style="display:flex;"><span>				fathermap[fatherA]<span style="color:#f92672">=</span>fatherB;
</span></span><span style="display:flex;"><span>				sizemap[fatherB]<span style="color:#f92672">=</span>aSize <span style="color:#f92672">+</span> bSize;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>				fathermap[fatherB]<span style="color:#f92672">=</span>fatherA;
</span></span><span style="display:flex;"><span>				sizemap[fatherA]<span style="color:#f92672">=</span>aSize <span style="color:#f92672">+</span> bSize;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isSameSet</span>(Node a, Node b) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> (findHeadUnRecur(a) <span style="color:#f92672">==</span> findHeadUnRecur(b)) <span style="color:#f92672">?</span> true <span style="color:#f92672">:</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><hr>
<h2 id="part-4--字典树-tri树-前缀树">Part 4  字典树 tri树 前缀树</h2>
<p>字典树是一个树状结构，用来存储字符串信息，每个树枝代表一个字符，每个节点拥有三个成员，path表示字符串加入树走过该结点的次数，end表示以该结点结尾的字符串数量，nexts表示26个孩子，按英文字符A-Z顺序表示，指针指向NULL表示没有字符。以下面的树为例，表示字符串inn,int,tea,ten,to。</p>
<!-- raw HTML omitted -->
<p>path主要解决前缀字符串问题，给定前缀str，查询字符串中有多少是以str为前缀的树，只要遍历返回最后一个结点的path值即为所求。
end主要解决查询字符串是否存在问题。比如给定abc和ab建的tri树是相同的，我们此时查ab是否存在就不得而知，所以加入end，遍历字符串，看看最后一个结点end值是否为0，就知道是否存在，如果存在还能知道存在几个。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TriNode</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> path; <span style="color:#75715e">//树经过该结点多少次
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> end; <span style="color:#75715e">//以该结点结尾结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	TriNode<span style="color:#f92672">*</span> nexts[<span style="color:#ae81ff">26</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	TriNode() {
</span></span><span style="display:flex;"><span>		path <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		end <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">26</span>; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>			nexts[i] <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TriTree</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	TriNode root;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> insert(string word) {
</span></span><span style="display:flex;"><span>		TriNode node <span style="color:#f92672">=</span> root;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> word.length(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> word[i] <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (node.nexts[index] <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>				node.nexts[index] <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TriNode();
</span></span><span style="display:flex;"><span>			node <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>node.nexts[index];
</span></span><span style="display:flex;"><span>			node.path<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		node.end<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">deleteWord</span>(string word) {
</span></span><span style="display:flex;"><span>		TriNode node <span style="color:#f92672">=</span> root;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> word.length(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> word[i] <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">--</span>node.nexts[index]<span style="color:#f92672">-&gt;</span>path <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>				node.nexts[index] <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			node <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>node.nexts[index];
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		node.end<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">search</span>(string word) {
</span></span><span style="display:flex;"><span>		TriNode node <span style="color:#f92672">=</span> root;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> word.length(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> word[i] <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (node.nexts[index] <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>			node <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>node.nexts[index];
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (node.end <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">prefixNumber</span>(string pre) {
</span></span><span style="display:flex;"><span>		TriNode node <span style="color:#f92672">=</span> root;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> pre.length(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> pre[i] <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (node.nexts[index] <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>			node <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>node.nexts[index];
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> node.path;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="第六讲-贪心">第六讲 贪心</h1>
<p>贪心是一种策略，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。这就存在一个问题，我的贪心策略不一定是对的，同时也存在很多的贪心策略，贪心策略很不容易证明，所以一般用对数器验证贪心策略是否正确，选择的贪心策略必须具备无后效性，选择这个以后不影响后面的结果。</p>
<h2 id="part-1--合成最小字符串">Part 1  合成最小字符串</h2>
<p>给定字符串数组，要把他们全部合成一个完整的字符串，要求合成的字符串字典序最小。</p>
<p>分析：
<strong>贪心策略1</strong>：把所有子串按字典序排序升序之后，两两连接，就是最小的。这样其实是错误的，举例：ba和b，贪心之后为bba，可是实际上bab是最小的。</p>
<p><strong>贪心策略2</strong>：两两比较字串a和b，比较策略不是两个字符串直接按字典序比较，而是a+b&lt;b+a的话a排在b前面，这样就解决了ba和b的问题。为了证明这种贪心策略是否正确，首先证明这种排序是可传递的，即a&lt;b且b&lt;c推出a&lt;c。我们把字符串看成k进制数，12 + 34=12 * 10^2+34，字符串a+b记为a*m(b)+a</p>
<p>$$
a+b \leq b+a=&gt;a<em>m(b)+b \leq b</em>m(a)+a   =&gt;   a<em>m(b)<em>c \leq b</em>m(a)<em>c+ac-bc\
b+c \leq c+b=&gt;b</em>m(c)+c \leq c</em>m(b)+b   =&gt;   b<em>m(c)<em>a+ca-ba \leq c</em>m(a)<em>a\
由上式可推出:\
b</em>m(c)<em>a-ba \leq b</em>m(a)<em>c-bc   =&gt;    a</em>m(c)+c \leq c</em>m(a)+a=&gt; a+c \leq c+a
$$</p>
<p>接下来证明经过这种规则排序后合成的字符串是最小的，我们任意交换两个子串的位置，得到的字符串一定比原来的大。比如现有已经排好序的字符串 am~1~m~2~&hellip;&hellip;m~k~b，交换ab子串得到的bm~1~m~2~&hellip;&hellip;m~k~a 一定大于原来的。因为以前已经排好序了，a+m~i~&lt;=m~i~+a ，m~i~+b&lt;=b+m~i~</p>
<p>$$
&hellip;am_{1} m_{2}&hellip;&hellip;m_{k}b&hellip; \leq &hellip;m_{1}am_{2}&hellip;&hellip;m_{k}b&hellip;\
&hellip;am_{1} m_{2}&hellip;&hellip;m_{k}b&hellip; \leq &hellip;m_{1}m_{2}&hellip;&hellip;m_{k}ba&hellip;\
&hellip;m_{1}m_{2}&hellip;&hellip;m_{k}ba&hellip; \leq &hellip;m_{1}m_{2}&hellip;&hellip;bm_{k}a&hellip;\
&hellip;m_{1}m_{2}&hellip;&hellip;m_{k}ba&hellip; \leq &hellip;bm_{1}m_{2}&hellip;&hellip;m_{k}a&hellip;
$$
费了半天劲终于证明了贪心策略的正确性，所以一般贪心策略不用证明，直接用就行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">cmp</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">operator</span> ()(string a, string b) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (a <span style="color:#f92672">+</span> b <span style="color:#f92672">&lt;</span> b <span style="color:#f92672">+</span> a)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>string <span style="color:#a6e22e">mixMinString</span>(vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> arr) {
</span></span><span style="display:flex;"><span>	priority_queue<span style="color:#f92672">&lt;</span>string,vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span>,cmp<span style="color:#f92672">&gt;</span> help;<span style="color:#75715e">//优先队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> arr.size(); <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>		help.push(arr[i]);
</span></span><span style="display:flex;"><span>	string ans <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>help.empty()) {
</span></span><span style="display:flex;"><span>		ans <span style="color:#f92672">+=</span> help.top();
</span></span><span style="display:flex;"><span>		help.pop();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="part-2--切金条">Part 2  切金条</h2>
<p>一块金条切两半，需要花费和长度相同的钱，比如长度20的金条，切一刀需要花费20，现给定一数组[5,5,10]，表示金条需要切成5，5，10三段，所以总共需要切两刀，共需要花费30，才能切开。现在输入一个数组，返回分割的最小代价</p>
<p>分析：哈夫曼树最小代价和即为所求。贪心策略：每次切出来的一段一定是最长的一段，另一段再找出最长的一段，保证后续切金条花费最少。我们反着来，每次选最小的两个加起来，再加进数组，重复此操作，即可。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">cmp</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">operator</span> ()(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (a <span style="color:#f92672">&lt;=</span> b)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">minCost</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> arr) {
</span></span><span style="display:flex;"><span>	priority_queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>,cmp<span style="color:#f92672">&gt;</span> help;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> arr.size(); <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>		help.push(arr[i]);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (help.size() <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		temp <span style="color:#f92672">+=</span> help.top();
</span></span><span style="display:flex;"><span>		help.pop();
</span></span><span style="display:flex;"><span>		temp <span style="color:#f92672">+=</span> help.top();
</span></span><span style="display:flex;"><span>		help.pop();
</span></span><span style="display:flex;"><span>		help.push(temp);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> help.top();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="part-3--工程最大利润">Part 3  工程最大利润</h2>
<p>输入cost和profit数组，表示各个项目的门槛和利润，一次只能做一个项目，收益为门槛加上利润，再次输入本金和最多做的项目数，输出最终的最大收益</p>
<p>分析：在做的项目数小于规定的前提下，在小于当前本金的所有项目中选出利润最大的做，直到本金小于现有所有项目门槛或者达到最大项目数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">node</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> weight;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> value;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">cmpMin</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">operator</span> ()(node a, node b) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> a.weight <span style="color:#f92672">&gt;</span> b.weight;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">cmpMax</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">operator</span> ()(node a, node b) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> a.value <span style="color:#f92672">&lt;=</span> b.value;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxProfit</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> weight, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> value, <span style="color:#66d9ef">int</span> maxProject, <span style="color:#66d9ef">int</span> ownMoney) {
</span></span><span style="display:flex;"><span>	priority_queue<span style="color:#f92672">&lt;</span>node, vector<span style="color:#f92672">&lt;</span>node<span style="color:#f92672">&gt;</span>, cmpMin<span style="color:#f92672">&gt;</span> minProj;
</span></span><span style="display:flex;"><span>	priority_queue<span style="color:#f92672">&lt;</span>node, vector<span style="color:#f92672">&lt;</span>node<span style="color:#f92672">&gt;</span>, cmpMax<span style="color:#f92672">&gt;</span> maxProj;
</span></span><span style="display:flex;"><span>	node<span style="color:#f92672">*</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> node[weight.size()];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> weight.size(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>		a[i].weight <span style="color:#f92672">=</span> weight[i];
</span></span><span style="display:flex;"><span>		a[i].value <span style="color:#f92672">=</span> value[i];
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> weight.size(); <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>		minProj.push(a[i]);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> maxProject; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>minProj.empty() <span style="color:#f92672">&amp;&amp;</span> minProj.top().weight <span style="color:#f92672">&lt;=</span> ownMoney) {
</span></span><span style="display:flex;"><span>			maxProj.push(minProj.top());
</span></span><span style="display:flex;"><span>			minProj.pop();
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (maxProj.empty())
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> ownMoney;
</span></span><span style="display:flex;"><span>		ownMoney <span style="color:#f92672">+=</span> maxProj.top().value;
</span></span><span style="display:flex;"><span>		maxProj.pop();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> ownMoney;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="part-4--最大会议数">Part 4  最大会议数</h2>
<p>现有两数组存放会议开始时间和结束时间，只有一个会议室，会议室同一时间只能开一场会，现在输入开始时间，输出最多可以开多少场会</p>
<p>分析：贪心，每次选择最早结束的会议开。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">node</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> start;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> end;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">cmpMin</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">operator</span> ()(node a, node b) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> a.end <span style="color:#f92672">&gt;</span> b.end;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxProfit</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> start, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> end, <span style="color:#66d9ef">int</span> startTime) {
</span></span><span style="display:flex;"><span>	priority_queue<span style="color:#f92672">&lt;</span>node, vector<span style="color:#f92672">&lt;</span>node<span style="color:#f92672">&gt;</span>, cmpMin<span style="color:#f92672">&gt;</span> minProj;
</span></span><span style="display:flex;"><span>	node<span style="color:#f92672">*</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> node[start.size()];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> start.size(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>		a[i].start <span style="color:#f92672">=</span> start[i];
</span></span><span style="display:flex;"><span>		a[i].end <span style="color:#f92672">=</span> end[i];
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> start.size(); <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>		minProj.push(a[i]);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> start.size(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (startTime <span style="color:#f92672">&lt;=</span> minProj.top().start) {
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">++</span>ans;
</span></span><span style="display:flex;"><span>			startTime <span style="color:#f92672">=</span> minProj.top().end;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		minProj.pop();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="第七讲-动态规划和递归">第七讲 动态规划和递归</h1>
<p>暴力递归：</p>
<ol>
<li>把问题转化为规模缩小的同类子问题</li>
<li>由明确的中止递归条件</li>
<li>由得到子问题结果之后的决策过程</li>
<li>不记录每个子问题的解</li>
</ol>
<p>动态规划：</p>
<ol>
<li>从暴力递归来</li>
<li>将每个子问题的解记下来，避免重复运算，加速递归，以空间换时间</li>
<li>把递归抽象为状态表达</li>
<li>存在简化状态表达，使其更加简洁的可能</li>
</ol>
<h2 id="part-1--汉诺塔问题">Part 1  汉诺塔问题</h2>
<p>三根柱子，把n个盘子从左边的一根移到右边的一根，中间过程小的必须在大的上面，一次只能动一根柱子最上面的一个盘子，输出步骤。
分析：实际是个递归过程，移动n个盘子，子任务有三个，第一个移动n-1个盘子到中间的一根，第二个把第n个盘子移到右边柱子，第三个把n-1个移到右边的柱子。递归终止条件：如果当前n-1等于1，直接输出移动过程就行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">hanoiTower</span>(<span style="color:#66d9ef">int</span> level, string from, string help, string to) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (level <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;move &#34;</span> <span style="color:#f92672">&lt;&lt;</span> level <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; from &#34;</span> <span style="color:#f92672">&lt;&lt;</span> from <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; to &#34;</span> <span style="color:#f92672">&lt;&lt;</span> to <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}	
</span></span><span style="display:flex;"><span>	hanoiTower(level <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, from, to, help);
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;move &#34;</span> <span style="color:#f92672">&lt;&lt;</span> level <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; from &#34;</span> <span style="color:#f92672">&lt;&lt;</span> from <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; to &#34;</span> <span style="color:#f92672">&lt;&lt;</span> to <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	hanoiTower(level <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, help, from, to);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="part-2--输出所有子序列">Part 2  输出所有子序列</h2>
<p>一个字符串 s 被称作另一个字符串 S 的子序列，说明从序列 S 通过去除某些元素但不破坏余下元素的相对位置（在前或在后）可得到序列 s</p>
<p>分析：每个位置只有选这个字符和不选这个字符两种情况。从0位置开始输出子序列氛围两个子任务，第一个选择0位置字符输出1位置开始的子序列，第二个不选择0位置输出1位置开始的子序列。递归终止，位置来到字符串长度，直接输出序列即可。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PrintSubSequence</span>(string str, <span style="color:#66d9ef">int</span> i) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> str.length()) {
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> str <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	PrintSubSequence(str, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	str[i] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;#&#39;</span>;
</span></span><span style="display:flex;"><span>	PrintSubSequence(str, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="part-3--输出字符串所有全排列">Part 3  输出字符串所有全排列</h2>
<p>分析：每个位置选择从该位置到字符串结尾所有字符中间的一个字符，终止条件桶子序列。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PrintAllPermutations</span>(string str, <span style="color:#66d9ef">int</span> i) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> str.length()) {
</span></span><span style="display:flex;"><span>		cout <span style="color:#f92672">&lt;&lt;</span> str <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i; j <span style="color:#f92672">&lt;</span> str.length(); <span style="color:#f92672">++</span>j) {
</span></span><span style="display:flex;"><span>		swap(str, i, j);
</span></span><span style="display:flex;"><span>		PrintAllPermutations(str, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>		swap(str, j, i);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="part-4--寻最小路">Part 4  寻最小路</h2>
<p>给定一个二维数组，每个数都是正数，要求从左上走到右下角，每一步都只能向右或者向下。经过的数字累加，返回最小值</p>
<p>分析：每一步两种选择，两个子任务的结果之中的最大值，终止条件位置到达数组右下角返回0，到了底边只能向右，到了右边只能向下。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">minPath</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">**</span> matrix, <span style="color:#66d9ef">int</span> height, <span style="color:#66d9ef">int</span> width, <span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">int</span> j) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> height <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> j <span style="color:#f92672">==</span> width <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> matrix[i][j];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> height <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> matrix[i][j] <span style="color:#f92672">+</span> minPath(matrix, height, width, i, j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (j <span style="color:#f92672">==</span> width <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> matrix[i][j] <span style="color:#f92672">+</span> minPath(matrix, height, width, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, j);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> matrix[i][j] <span style="color:#f92672">+</span> min(minPath(matrix, height, width, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, j), 
</span></span><span style="display:flex;"><span>		minPath(matrix, height, width, i, j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>首先，递归函数变量为位置i,j我们将每个位置记为一种状态f(i,j)，那么就发现在递归函数状态f(2,3)和f(3,2)都需要计算f(3,3)的值，这就很浪费计算了两次，动态规划就是空间换时间，用一张表记录下这些状态的值f(i,j)，这张表场为j的范围，宽为i的范围，我们要求的是f(0,0)。现在通过递归终止条件我们知道f(height-1,width-1)这种状态的返回值直接知道，不需要计算m(height-1)(width-1)。还知道最后一行和最后一列的值只和相应的下一个状体的值有关，那么有f(height-1)(width-1)，我们就知道了f(height-2)(width-1)、f(height-3)(width-1)&hellip;&hellip;f(0)(width-1),f(height-1)(width-2)、f(height-1)(width-3)&hellip;&hellip;f(height)(0)的值。</p>
<p>举个例子，路径表为</p>
<table>
<thead>
<tr>
<th style="text-align:center">8</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">6</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
<p>dp表为</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center">12</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">9</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:center">10</td>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
<p>接下来为了填充整张表我们现成的信息都用完了，只能看普通情况是如何，它取决于右边和下边的状态最大值。现在这张动态规划表已经有边界，从右下角开始向目标f(0,0)递推即可，这就是动态规划的过程。</p>
<p>dp表为</p>
<table>
<thead>
<tr>
<th style="text-align:center"><em>23</em></th>
<th style="text-align:center">18</th>
<th style="text-align:center">18</th>
<th style="text-align:center">12</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><em>15</em></td>
<td style="text-align:center"><em>13</em></td>
<td style="text-align:center">11</td>
<td style="text-align:center">9</td>
</tr>
<tr>
<td style="text-align:center">18</td>
<td style="text-align:center"><em>12</em></td>
<td style="text-align:center"><em>8</em></td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:center">10</td>
<td style="text-align:center"><em>4</em></td>
<td style="text-align:center"><em>2</em></td>
</tr>
</tbody>
</table>
<p>最终求得<code>dp[0][0]</code>为23为所求，斜体为路径。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">minPathDP</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">**</span> matrix, <span style="color:#66d9ef">int</span> height, <span style="color:#66d9ef">int</span> width) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span><span style="color:#f92672">**</span> dp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> [height];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> height; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>		dp[i] <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[width];
</span></span><span style="display:flex;"><span>	dp[height <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][width <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> matrix[height <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][width <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> width <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>; j <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>j)
</span></span><span style="display:flex;"><span>		dp[height <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j] <span style="color:#f92672">=</span> matrix[height <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j] <span style="color:#f92672">+</span> dp[height <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> height <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>i)
</span></span><span style="display:flex;"><span>		dp[i][width <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> matrix[i][width <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> dp[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][width <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> height <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>i)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> width <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>; j <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>j)
</span></span><span style="display:flex;"><span>			dp[i][j] <span style="color:#f92672">=</span> matrix[i][j] <span style="color:#f92672">+</span> min(dp[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][j], dp[i][j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> dp[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="part-5--数组累加">Part 5  数组累加</h2>
<p>给定一个数组和整数aim，可任意选择数组中的数字，能不能累加得到aim，可以返回true，否则返回false</p>
<p>分析：子任务两个，一个选当前位置数，一个不选当前位置数，两个结果取或。终止条件：位置到达最后，或者加和大于aim</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">addToAim</span>(<span style="color:#66d9ef">int</span> num[], <span style="color:#66d9ef">int</span> aim, <span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">int</span> alreadySum, <span style="color:#66d9ef">int</span> length) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (alreadySum <span style="color:#f92672">==</span> aim)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> length <span style="color:#f92672">||</span> alreadySum <span style="color:#f92672">&gt;</span> aim)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> addToAim(num, aim, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, alreadySum <span style="color:#f92672">+</span> num[i], length) <span style="color:#f92672">||</span> 
</span></span><span style="display:flex;"><span>		addToAim(num, aim, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, alreadySum, length);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>下面改DP，变量有两个位置i和加和alreadySum，dp表长0-aim宽0-length。所求值为<code>dp[0][0]</code>，已知最右边的一列和最下边一行和加上<code>num[i]</code>之后大于aim的位置。普通位置需要下面一个位置和下面一个位置向右偏移<code>num[i]</code>的位置的值，综上即可建立dp表。</p>
<p>举个例子，数组 1，2，aim=3
dp表</p>
<table>
<thead>
<tr>
<th style="text-align:center">T</th>
<th style="text-align:center">T</th>
<th style="text-align:center">F</th>
<th style="text-align:center">T</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">F</td>
<td style="text-align:center">T</td>
<td style="text-align:center">F</td>
<td style="text-align:center">T</td>
</tr>
<tr>
<td style="text-align:center">F</td>
<td style="text-align:center">F</td>
<td style="text-align:center">F</td>
<td style="text-align:center">T</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">addToAimDP</span>(<span style="color:#66d9ef">int</span> num[], <span style="color:#66d9ef">int</span> aim, <span style="color:#66d9ef">int</span> length) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span><span style="color:#f92672">**</span> dp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> [length <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> length <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>		dp[i] <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[aim <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> length; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>		dp[i][aim] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> aim; <span style="color:#f92672">++</span>j)
</span></span><span style="display:flex;"><span>		dp[length][j] <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>i) 
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> aim <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>j) 
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (j <span style="color:#f92672">+</span> num[i] <span style="color:#f92672">&gt;</span> aim)
</span></span><span style="display:flex;"><span>				dp[i][j] <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>				dp[i][j] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][j] <span style="color:#f92672">||</span> dp[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">+</span> num[i]];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> dp[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="part-6--背包问题">Part 6  背包问题</h2>
<p>给定两个数组w和v，长度相等，<code>w[i]</code>表示第i件商品的重量，<code>v[i]</code>表示第i件商品的价值，给定整数bag，挑选的商品重量不能超过bag，返回满足条件的最大价值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">bagProblemRecur</span>(<span style="color:#66d9ef">int</span> w[], <span style="color:#66d9ef">int</span> v[], <span style="color:#66d9ef">int</span> sumWeight, <span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">int</span> bag, <span style="color:#66d9ef">int</span> length) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> length)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> choice <span style="color:#f92672">=</span> (sumWeight <span style="color:#f92672">+</span> w[i] <span style="color:#f92672">&gt;</span> bag) <span style="color:#f92672">?</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>		v[i] <span style="color:#f92672">+</span> bagProblemRecur(w, v, sumWeight <span style="color:#f92672">+</span> w[i], i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, bag, length);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> max(bagProblemRecur(w, v, sumWeight, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, bag, length), choice);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>下面改DP，变量有位置i和加和sumWeight，dp表长0-bag宽0-length。所求值为<code>dp[0][0]</code>，已知最右边的一列和最下边一行均为0。普通位置需要下面一个位置和下面一个位置向右偏移<code>w[i]</code>的位置的值(偏移超过bag记为0)，综上即可建立dp表。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">bagProblemDP</span>(<span style="color:#66d9ef">int</span> w[], <span style="color:#66d9ef">int</span> v[], <span style="color:#66d9ef">int</span> bag, <span style="color:#66d9ef">int</span> length) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span><span style="color:#f92672">**</span> dp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> [length <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> length <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>		dp[i] <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[bag <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> bag <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">++</span>j)
</span></span><span style="display:flex;"><span>		dp[length][j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> length; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>		dp[i][bag] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>i) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> bag <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>j) {
</span></span><span style="display:flex;"><span>			dp[i][j] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][j];
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (j <span style="color:#f92672">+</span> w[i] <span style="color:#f92672">&lt;=</span> bag)
</span></span><span style="display:flex;"><span>				dp[i][j] <span style="color:#f92672">=</span> max(dp[i][j], v[i] <span style="color:#f92672">+</span> dp[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">+</span> w[i]]);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> dp[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="第八讲">第八讲</h1>
<h2 id="part-1--kmp算法">Part 1  KMP算法</h2>
<p>KMP算法解决字符串中找子串第一次出现的位置。字符串长度n，子串长度m，时间复杂度O(m+n)，m为计算next数组需要的时间，n为遍历查找的时间，空间复杂度O(m)，相比于一般的暴力比较时间复杂度提高很多。</p>
<p>空间换时间，用next数组加速遍历，暴力法每次不匹配都往回退到开始匹配的下一个位置，就很浪费时间，做了一些无意义的比较。KMP主要通过最长前缀解决不必要的回溯问题。</p>
<p>首先是前缀数组，长度为子串长度，每个位置存放该位置之前的字符串最长前缀、后缀(不包括整个字符串)相同的长度。比如aaaa应为3。接下来求解求解整个子串的next值，0位置之前没有字符串记为-1，1位置前只有一个字符记为0，之后的位置是一个递归过程。求解<code>next[i]</code>的值，首先看看<code>next[i-1]</code>的值，如果<code>str[next[i-1]]</code>和<code>str[i-1]</code>相等，说明前一个位置的next值是可以用的，加一就是当前值。如果不等，就看看<code>next[i-1]</code>位置的next值，直到前缀为-1都没有匹配，next值为0，思想就是看看到底之前有多少公共前后缀可以使用。</p>
<!-- raw HTML omitted -->
<p>接下来有了next数组，我们主要解决当出现字符串与子串不匹配时，回溯到哪里避免无效比较。求不匹配位置next值，利用前缀和后缀相同，i不动，j移动到<code>next[i]</code>，继续匹配，这里其实否定了图中从k长度内开始匹配的可能性，下面证明为什么可以否定。不妨假设，从图中k长度区域中的某个x位置开始可以匹配，那么不妨设到a之前匹配，所以子串中从0开始相同长度和字符串中x-a区域匹配，由于灰色段子串字符串是相同的，所以子串在b之前也有和字符串相同的后缀x-a，也就是子串b之前出现了x-a区域的后缀和前缀相同，这和A区域最长前后缀相同的结论矛盾所以显然错误。</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">getNexts</span>(string str) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> next <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[str.length()];
</span></span><span style="display:flex;"><span>	next[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;next[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> frontNext <span style="color:#f92672">=</span> next[<span style="color:#ae81ff">1</span>], i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;<span style="color:#75715e">//frontNext记录前一个位置的next值用来比较
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> str.length()) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (str[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> str[frontNext])
</span></span><span style="display:flex;"><span>			next[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>frontNext;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (frontNext <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)<span style="color:#75715e">//frontNext&lt;=0,说明已经没有相同前后缀，不用找了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				frontNext <span style="color:#f92672">=</span> next[frontNext];
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>				next[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> next;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">KMP</span>(string str, string subStr) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> next <span style="color:#f92672">=</span> getNexts(subStr);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> str.length() <span style="color:#f92672">&amp;&amp;</span> j <span style="color:#f92672">&lt;</span> subStr.length()) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (str[i] <span style="color:#f92672">==</span> subStr[j]) {
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">++</span>i; <span style="color:#f92672">++</span>j;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (j <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)<span style="color:#75715e">//第一个位置都没匹配，没有相同前后缀可用，直接比较下一个
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>				j <span style="color:#f92672">=</span> next[j];
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> (j <span style="color:#f92672">==</span> subStr.length()) <span style="color:#f92672">?</span> i <span style="color:#f92672">-</span> j : <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>KMP应用</strong>：</p>
<p><strong>相同前后缀</strong>：给定一字符串，在末尾添加一字符串使得新的大字符串包含两个原来的字符串，这两个字符串位置应该不同，输出最短的可能。比如：输入 aaaa，输出 aaaaa    输入 abcabc，输出 abcabcabc</p>
<p>分析：要包含两个原字符串，长度最短，那么利用相同的前后缀，利用了KMP中next数组，先求得整个字符串得最大前后缀，在结尾补上缺少得就行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>string <span style="color:#a6e22e">minTwoString</span>(string str) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> next <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[str.length() <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>	next[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; next[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> frontNext <span style="color:#f92672">=</span> next[<span style="color:#ae81ff">1</span>], i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;=</span> str.length()) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (str[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> str[frontNext])
</span></span><span style="display:flex;"><span>			next[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>frontNext;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (frontNext <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>				frontNext <span style="color:#f92672">=</span> next[frontNext];
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>				next[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	str <span style="color:#f92672">+=</span> str.substr(next[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>], str.length() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> str;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<p><strong>二叉树找子树删除子树</strong>：给定一个二叉树和一个子树，看这棵树中有没有子树，有的话删除，没有返回false</p>
<p>分析：二叉树序列化为字符串遍历顺序无所谓，子树序列化，KMP找子串，存在得话删除子串，补上一个空结点标志，完成。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;  </span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sstream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">BiTNode</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> data;
</span></span><span style="display:flex;"><span>	BiTNode<span style="color:#f92672">*</span> lchild;
</span></span><span style="display:flex;"><span>	BiTNode<span style="color:#f92672">*</span> rchild;
</span></span><span style="display:flex;"><span>}BiTNode, <span style="color:#f92672">*</span> BiTree;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Ans</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">bool</span> isSubString;
</span></span><span style="display:flex;"><span>	BiTree T;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PreOrder</span>(BiTree T) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (T <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> T<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>	PreOrder(T<span style="color:#f92672">-&gt;</span>lchild);
</span></span><span style="display:flex;"><span>	PreOrder(T<span style="color:#f92672">-&gt;</span>rchild);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">getNexts</span>(string str) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> next <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[str.length()];
</span></span><span style="display:flex;"><span>	next[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; next[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> frontNext <span style="color:#f92672">=</span> next[<span style="color:#ae81ff">1</span>], i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;<span style="color:#75715e">//frontNext记录前一个位置的next值用来比较
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;=</span> str.length()) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (str[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> str[frontNext])
</span></span><span style="display:flex;"><span>			next[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>frontNext;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (frontNext <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)<span style="color:#75715e">//frontNext&lt;=0,说明已经没有相同前后缀，不用找了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				frontNext <span style="color:#f92672">=</span> next[frontNext];
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>				next[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> next;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">KMP</span>(string str, string subStr) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> next <span style="color:#f92672">=</span> getNexts(subStr);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> str.length() <span style="color:#f92672">&amp;&amp;</span> j <span style="color:#f92672">&lt;</span> subStr.length()) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (str[i] <span style="color:#f92672">==</span> subStr[j]) {
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">++</span>i; <span style="color:#f92672">++</span>j;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (j <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)<span style="color:#75715e">//第一个位置都没匹配，没有相同前后缀可用，直接比较下一个
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>				j <span style="color:#f92672">=</span> next[j];
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> (j <span style="color:#f92672">==</span> subStr.length()) <span style="color:#f92672">?</span> i <span style="color:#f92672">-</span> j : <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>string <span style="color:#a6e22e">BiTreeSquence</span>(BiTree T) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (T <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;# &#34;</span>;<span style="color:#75715e">//留空格是为了复原树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	string str <span style="color:#f92672">=</span> to_string(T<span style="color:#f92672">-&gt;</span>data) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>	str <span style="color:#f92672">+=</span> BiTreeSquence(T<span style="color:#f92672">-&gt;</span>lchild);
</span></span><span style="display:flex;"><span>	str <span style="color:#f92672">+=</span> BiTreeSquence(T<span style="color:#f92672">-&gt;</span>rchild);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> str;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>BiTree <span style="color:#a6e22e">BiTreeUnSquence</span>(vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>tree, BiTree<span style="color:#f92672">&amp;</span> T) {
</span></span><span style="display:flex;"><span>	string temp <span style="color:#f92672">=</span> tree.front();
</span></span><span style="display:flex;"><span>	tree.erase(tree.begin());
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (temp <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;#&#34;</span>)
</span></span><span style="display:flex;"><span>		T <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		T <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BiTNode;
</span></span><span style="display:flex;"><span>		T<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> atoi(temp.c_str());<span style="color:#75715e">//string 转 int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		BiTreeUnSquence(tree, T<span style="color:#f92672">-&gt;</span>lchild);
</span></span><span style="display:flex;"><span>		BiTreeUnSquence(tree, T<span style="color:#f92672">-&gt;</span>rchild);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> T;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> processStream(string str) {<span style="color:#75715e">//把全部节点值加入向量中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	string temp;
</span></span><span style="display:flex;"><span>	vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> help;
</span></span><span style="display:flex;"><span>	istringstream <span style="color:#a6e22e">stream</span>(str);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (stream <span style="color:#f92672">&gt;&gt;</span> temp)
</span></span><span style="display:flex;"><span>		help.push_back(temp);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> help;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Ans <span style="color:#a6e22e">findSubBiTree</span>(BiTree<span style="color:#f92672">&amp;</span> T, BiTree subTree) {
</span></span><span style="display:flex;"><span>	Ans ans;
</span></span><span style="display:flex;"><span>	string tree <span style="color:#f92672">=</span> BiTreeSquence(T);
</span></span><span style="display:flex;"><span>	string subtree <span style="color:#f92672">=</span> BiTreeSquence(subTree);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> loc <span style="color:#f92672">=</span> KMP(tree, subtree);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (loc <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>		ans.isSubString <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>		ans.T <span style="color:#f92672">=</span> T;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	tree.insert(loc, <span style="color:#e6db74">&#34;# &#34;</span>);
</span></span><span style="display:flex;"><span>	tree.erase(loc <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>, subtree.length());<span style="color:#75715e">//删除子树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> treeNum;
</span></span><span style="display:flex;"><span>	treeNum <span style="color:#f92672">=</span> processStream(tree);
</span></span><span style="display:flex;"><span>	ans.isSubString <span style="color:#f92672">=</span> BiTreeUnSquence(treeNum, ans.T);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	BiTNode a, b, c, d, e, f;
</span></span><span style="display:flex;"><span>	a.data <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; b.data <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; c.data <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>	d.data <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>; e.data <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; f.data <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>	a.lchild <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>b; a.rchild <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>c;
</span></span><span style="display:flex;"><span>	b.lchild <span style="color:#f92672">=</span> NULL; b.rchild <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>d;
</span></span><span style="display:flex;"><span>	c.lchild <span style="color:#f92672">=</span> NULL; c.rchild <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	d.lchild <span style="color:#f92672">=</span> NULL; d.rchild <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	e.lchild <span style="color:#f92672">=</span> NULL; e.rchild <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>f;
</span></span><span style="display:flex;"><span>	f.lchild <span style="color:#f92672">=</span> NULL; f.rchild <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	BiTree t <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>a, subt <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>e;
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> findSubBiTree(t, subt).isSubString <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	PreOrder(findSubBiTree(t, subt).T);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="part-2--manacher算法">Part 2  manacher算法</h2>
<p>给定一个字符串，求出其最长回文子串。例如：</p>
<ol>
<li>s=&ldquo;abcd&rdquo;，最长回文长度为 1；</li>
<li>s=&ldquo;ababa&rdquo;，最长回文长度为 5；</li>
<li>s=&ldquo;abccb&rdquo;，最长回文长度为 4，即 bccb</li>
</ol>
<p>以上问题的传统思路大概是，遍历每一个字符，以该字符为中心向两边查找。其时间复杂度为 <code>O(n^2)</code>，效率很差。Manacher 算法，该算法可以把时间复杂度提升到 <code>O(n)</code>。下面来看看马拉车算法是如何工作的。</p>
<p>由于回文分为偶回文（比如 bccb）和奇回文（比如 bcacb），而在处理奇偶问题上会比较繁琐，所以在字符串首尾，及各字符间各插入一个字符（前提这个字符未出现在串里）。</p>
<p>举个例子：<code>s=&quot;abbahopxpo&quot;</code>，转换为<code>s_new=&quot;#a#b#b#a#h#o#p#x#p#o#&quot;</code>，如此，s 里起初有一个偶回文<code>abba</code>和一个奇回文<code>opxpo</code>，被转换为<code>#a#b#b#a#</code>和<code>#o#p#x#p#o#</code>，长度都转换成了<strong>奇数</strong>。这样奇数回文就可以从中间向两边展开。manacher同样是空间换时间，用<code>int p[]</code>数组记录每个位置的回文半径，传统manacher算法中数组<code>p</code>中的每个位置都要从中心向两边展开，manacher就是利用数组<code>p</code>前面位置的值加速后面位置值的求解。</p>
<table>
<thead>
<tr>
<th style="text-align:center">i</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
<th style="text-align:center">10</th>
<th style="text-align:center">11</th>
<th style="text-align:center">12</th>
<th style="text-align:center">13</th>
<th style="text-align:center">14</th>
<th style="text-align:center">15</th>
<th style="text-align:center">16</th>
<th style="text-align:center">17</th>
<th style="text-align:center">18</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">s_new[i]</td>
<td style="text-align:center">#</td>
<td style="text-align:center">a</td>
<td style="text-align:center">#</td>
<td style="text-align:center">b</td>
<td style="text-align:center">#</td>
<td style="text-align:center">b</td>
<td style="text-align:center">#</td>
<td style="text-align:center">a</td>
<td style="text-align:center">#</td>
<td style="text-align:center">h</td>
<td style="text-align:center">#</td>
<td style="text-align:center">o</td>
<td style="text-align:center">#</td>
<td style="text-align:center">p</td>
<td style="text-align:center">#</td>
<td style="text-align:center">x</td>
<td style="text-align:center">#</td>
<td style="text-align:center">p</td>
<td style="text-align:center">#</td>
</tr>
<tr>
<td style="text-align:center">p[i]</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">5</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">4</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>这样我们就可以看出，最大回文长度为<code>max(p[i])-1</code>注意这里数组<code>p</code>存的是半径，我们要求的是直径，因为空隙中加了一个字符，所以半径-1刚好等于所求。接下来还需要两个变量mx 和 id 。mx 代表以 id 为中心的最长回文的右边界(只有当前位置回文中心加上最大回文半径大于当前有边界时，右边界才会更新)，也就是mx = id + p[id]。我们利用<code>p[j]</code>来加快查找。</p>
<!-- raw HTML omitted -->
<p>根据回文的性质，<code>p[i]</code>的值基于以下四种情况得出：</p>
<p>(1):<strong>j 的回文串有一部分在回文右边界的之外</strong>，如下图：</p>
<p><img src="https://raw.githubusercontent.com/xiaoqiao12138/PicBackUp/main/img/20210701153403.png" alt="img"></p>
<p>上图中，黑线右边界为 id 的回文右边界，i 与 j 关于 id 对称，红线为 j 的回文。那么根据代码此时<code>p[i] = mx - i</code>就是 <code>i</code> 到边界 <code>mx</code>的距离，即紫线。那么<code>p[i]</code>还可以更大么？答案是不可能！</p>
<p><img src="https://raw.githubusercontent.com/xiaoqiao12138/PicBackUp/main/img/20210701153408.png" alt="img"></p>
<p>假设右侧新增的紫色部分是<code>p[i]</code>可以增加的部分，那么根据回文右边界的性质，a 不等于 d ，根据j的回文性质，<code>a=b,c=d</code>，根据id内回文的性质<code>b=c</code>，综上<code>a!=d</code>，所以i位置最大回文长度为<code>mx - 1</code></p>
<p>(2):<strong>j 回文串全部在 id 的内部</strong>，如下图：</p>
<p><img src="https://raw.githubusercontent.com/xiaoqiao12138/PicBackUp/main/img/20210701153415.png" alt="img"></p>
<p>此时i位置回文半径等于j位置回文半径。利用(1)方式容易证明不能再扩大了</p>
<p>(3):<strong>j 回文串左端正好与 id 的回文串左端重合</strong>，见下图：</p>
<p><img src="https://raw.githubusercontent.com/xiaoqiao12138/PicBackUp/main/img/20210701153419.png" alt="img"></p>
<p>此时回文半径最少为<code>mx-1==p[j]</code>，还需要向外边扩看看回文半径会不会增加。</p>
<p>(4):<strong>i位置不在最右回文边界内</strong>：这种情况按照暴力方法直接向两边扩展</p>
<p>通过以上分析，我们发现，回文边界一直向右移动，<code>i</code>一直向右移动，没有回溯的过程所以时间复杂度<code>O(N)</code>。以下为代码，改动增加返回值最大回文长度字符串。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">maxPalindromicString</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> length;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> PalindromicMiddle;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>maxPalindromicString <span style="color:#a6e22e">Manacher</span>(string str) {
</span></span><span style="display:flex;"><span>	string strNew <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;#&#34;</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> str.length(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>		strNew <span style="color:#f92672">+=</span> str[i];
</span></span><span style="display:flex;"><span>		strNew <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;#&#34;</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[strNew.length()];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> R <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, C <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	maxPalindromicString ans;
</span></span><span style="display:flex;"><span>	ans.length <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; ans.PalindromicMiddle <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> strNew.length(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>		p[i] <span style="color:#f92672">=</span> (i <span style="color:#f92672">&lt;</span> R) <span style="color:#f92672">?</span> min(p[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> C <span style="color:#f92672">-</span> i], R <span style="color:#f92672">-</span> i) <span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> (i <span style="color:#f92672">+</span> p[i] <span style="color:#f92672">&lt;</span> strNew.length() <span style="color:#f92672">&amp;&amp;</span> i <span style="color:#f92672">-</span> p[i] <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (strNew[i <span style="color:#f92672">+</span> p[i]] <span style="color:#f92672">==</span> strNew[i <span style="color:#f92672">-</span> p[i]])
</span></span><span style="display:flex;"><span>				<span style="color:#f92672">++</span>p[i];
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (i <span style="color:#f92672">+</span> p[i] <span style="color:#f92672">&gt;</span> R) {<span style="color:#75715e">//更新回文右边界和回文中心
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			R <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> p[i];
</span></span><span style="display:flex;"><span>			C <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (ans.length <span style="color:#f92672">&lt;</span> p[i]) {<span style="color:#75715e">//处理返回值信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			ans.length <span style="color:#f92672">=</span> p[i];
</span></span><span style="display:flex;"><span>			ans.PalindromicMiddle <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	ans.length <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	string s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;taabbbaak&#34;</span>;
</span></span><span style="display:flex;"><span>	maxPalindromicString ans <span style="color:#f92672">=</span> Manacher(s);
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> ans.length <span style="color:#f92672">&lt;&lt;</span> endl <span style="color:#f92672">&lt;&lt;</span> s.substr(ans.PalindromicMiddle <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span> ans.length <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>, ans.length) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>p[i] = (i &lt; R) ? min(p[2 * C - i], R - i) : 1;</code>   这一句代码非常精髓，可以验证：可能性1中<code>p[i]</code>应为<code>R-i</code>，这时候<code>R-i&lt;p[2 * C - i]</code>，可能性2中<code>p[i]</code>应为<code>p[2 * C - i]</code>，此时<code>R-i&gt;p[2 * C - i]</code>，可能性3中<code>R-i=p[2 * C - i]</code>，取最小值都一样。所以当<code>(i&lt;R)</code>时<code>p[i]</code>取值正常，当<code>i&gt;=R</code>时，<code>p[i]</code>得取值1刚好可以作为接下来扩展遍历得位置记录，妙哉！</p>
<p><strong>Manacher应用</strong>：</p>
<p>给定一字符串，结尾添加字符串使整个新字符串回文，要求新字符串最短。</p>
<p>分析：现在应该从数组结尾开始找一找最长得回文子串，剩下数组前面不回文的字符在结尾补齐。这就需要当Manacher回文右边界到达字符串结尾时，直接退出，这时候回文中心就是最后整个字符串得问问中心，根据边界和回文中心补齐其他字符。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>string <span style="color:#a6e22e">minPalindromicString</span>(string str) {
</span></span><span style="display:flex;"><span>	string strNew <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;#&#34;</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> str.length(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>		strNew <span style="color:#f92672">+=</span> str[i];
</span></span><span style="display:flex;"><span>		strNew <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;#&#34;</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[strNew.length()];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> R <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, C <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> strNew.length(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>		p[i] <span style="color:#f92672">=</span> (i <span style="color:#f92672">&lt;</span> R) <span style="color:#f92672">?</span> min(p[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> C <span style="color:#f92672">-</span> i], R <span style="color:#f92672">-</span> i) <span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> (i <span style="color:#f92672">+</span> p[i] <span style="color:#f92672">&lt;</span> strNew.length() <span style="color:#f92672">&amp;&amp;</span> i <span style="color:#f92672">-</span> p[i] <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (strNew[i <span style="color:#f92672">+</span> p[i]] <span style="color:#f92672">==</span> strNew[i <span style="color:#f92672">-</span> p[i]])
</span></span><span style="display:flex;"><span>				<span style="color:#f92672">++</span>p[i];
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (i <span style="color:#f92672">+</span> p[i] <span style="color:#f92672">&gt;</span> R) {
</span></span><span style="display:flex;"><span>			R <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> p[i];
</span></span><span style="display:flex;"><span>			C <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (R <span style="color:#f92672">==</span> strNew.length())
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	string temp <span style="color:#f92672">=</span> str.substr(<span style="color:#ae81ff">0</span>, (<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> C <span style="color:#f92672">-</span> R) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	reverse(temp.begin(), temp.end());
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> str <span style="color:#f92672">+</span> temp;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="第九讲">第九讲</h1>
<h2 id="part-1--bfprt算法">Part 1  BFPRT算法</h2>
<p>在一大堆数中求其前k大或前k小的问题，简称TOP-K问题。而目前解决TOP-K问题最有效的算法即是BFPRT算法，其又称为中位数的中位数算法，最坏时间复杂度为<code>O(N)</code>，排序就不如BFPRT</p>
<p>BFPRT算法步骤如下： 
（1）：选取主元； 
  （1.1）：将n个元素划分为⌊n/5⌋个组，每组5个元素，若有剩余，自成一组； 
  （1.2）：使用插入排序找到⌊n/5⌋个组中每一组的中位数； 
  （1.3）：对于（1.2）中找到的所有中位数，调用BFPRT算法求出它们的中位数，作为主元； 
（2）：以（1.3）选取的主元为分界点，把小于主元的放在左边，大于主元的放在右边；<strong>荷兰国旗</strong>
（3）：判断主元的位置与k的大小，要么直接在等于区域直接找到，要么有选择的对左边或右边递归。</p>
<p>下面分析为什么时间复杂度<code>O(N)</code>：
设整个任务时间复杂度<code>T(N)</code>，我们分析最坏情况，分组找到每个组得中位数,总共<code>N/5</code>个组找5个数中找中位数时间复杂度<code>O(1)</code>，总体时间复杂度<code>O(N)</code>，接下来找中位数数组得中位数，时间复杂度<code>T(N/5)</code>，比较影响效果得就是partition过程，我们看看为什么这样选择分界值就能很好。我们选出得中位数数组长度<code>N/5</code>的中位数作为分界值，那么就有<code>N/5/2=N/10</code>个中位数比他大，在这些中位数5个数的数组中至少有2个数比他们还大，因为他们也是5个数数组的中位数，那么总共至少存在<code>N/10+2*N/10=3*N/10</code>个数比分界值大，这样整个数组至多有<code>7*N/10</code>个数比分界值小，最坏的情况，我们接下来就要在这<code>7*N/10</code>个数中找答案。综上所述，我们得到：
$$
T(N)=T(\frac{N}{5})+T(\frac{7N}{10})+O(N)
$$
通过时间复杂度递归式，可证明最坏情况时间复杂度<code>T(N)=O(N)</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">swap</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">int</span> j) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> a[i];
</span></span><span style="display:flex;"><span>	a[i] <span style="color:#f92672">=</span> a[j];
</span></span><span style="display:flex;"><span>	a[j] <span style="color:#f92672">=</span> temp;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">partition</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> start, <span style="color:#66d9ef">int</span> end, <span style="color:#66d9ef">int</span> target) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> less <span style="color:#f92672">=</span> start <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, more <span style="color:#f92672">=</span> end <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, cur <span style="color:#f92672">=</span> start;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (cur <span style="color:#f92672">!=</span> more) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (a[cur] <span style="color:#f92672">==</span> target)
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">++</span>cur;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (a[cur] <span style="color:#f92672">&lt;</span> target)
</span></span><span style="display:flex;"><span>			swap(a, <span style="color:#f92672">++</span>less, cur<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>			swap(a, <span style="color:#f92672">--</span>more, cur);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> equal <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>	equal[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> less <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	equal[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">=</span>more <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> equal;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">findMiddleNum</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> start, <span style="color:#66d9ef">int</span> end) {
</span></span><span style="display:flex;"><span>	sort(a <span style="color:#f92672">+</span> start, a <span style="color:#f92672">+</span> end);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> a[(start <span style="color:#f92672">+</span> end) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">BFPRT</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> k, <span style="color:#66d9ef">int</span> start,<span style="color:#66d9ef">int</span> end) {<span style="color:#75715e">//k从1开始
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (end <span style="color:#f92672">==</span> start)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> a[end];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> length <span style="color:#f92672">=</span> ((end <span style="color:#f92672">-</span> start <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">5</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">?</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	length <span style="color:#f92672">+=</span> (end <span style="color:#f92672">-</span> start <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> newArr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[length];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> length; <span style="color:#f92672">++</span>i) <span style="color:#75715e">//min为最后一组不满5个准备
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		newArr[i] <span style="color:#f92672">=</span> findMiddleNum(a, start <span style="color:#f92672">+</span> i <span style="color:#f92672">*</span> <span style="color:#ae81ff">5</span>, min((start <span style="color:#f92672">+</span> i <span style="color:#f92672">*</span> <span style="color:#ae81ff">5</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span>), end));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> key <span style="color:#f92672">=</span> BFPRT(newArr, length <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0</span>, length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> equal <span style="color:#f92672">=</span> partition(a, start, end, key);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">delete</span>[]newArr;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (equal[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;=</span> k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> equal[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;=</span> k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> a[k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (equal[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&gt;</span> k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> BFPRT(a, k, start, equal[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> BFPRT(a, k, equal[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, end);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="part-2--滑动窗口">Part 2  滑动窗口</h2>
<p>由双端队列实现，队头和队尾都可以进也可以出，遍历线性结构的同时就可以利用滑动窗口得到子结构的一些性质，通常时间复杂度<code>O(N)</code></p>
<h3 id="滑动窗口最大值">滑动窗口最大值</h3>
<p>给定一个数组和一个大小w的窗口，窗口从数组左边滑到右边，每次滑一个位置记录当前窗口的最大值，如果数组长度n，则返回一个n-w+1的数组记录窗口各个位置的最大值。
输入 4 3 5 4 3 3 6 7   输出 5 5 5 4 6 7</p>
<p>分析：利用窗口结构，双端队列从头到尾必须由大到小，这样队头永远是当前窗口的最大值。队列存数组位置即可，进队列看是不是小于当前队尾的元素，如果大就让队尾元素出去，小就直接进队列。由于规定窗口只能为w，所以当队尾元素位置与队头元素位置差为w时，说明窗口已经为<code>w+1</code>了，要舍弃队头，<strong>不用管当前队列中有几个元素</strong>，队头一定是最大值，当前位置与队头元素位置的差等于w时，说明窗口已经进了w个元素，至于有没有因为不符合规则被从队尾踢出去的，我们不关心，已经进去w个窗口已经满了，应该向右滑动一个。每次记录最大值即可。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">maxInWindows</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> length, <span style="color:#66d9ef">int</span> windowSize) {
</span></span><span style="display:flex;"><span>	deque<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> windows;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> ans <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[length <span style="color:#f92672">-</span> windowSize <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> length; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>windows.empty() <span style="color:#f92672">&amp;&amp;</span> a[i] <span style="color:#f92672">&gt;</span> a[windows.back()])
</span></span><span style="display:flex;"><span>			windows.pop_back();
</span></span><span style="display:flex;"><span>		windows.push_back(i);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (i <span style="color:#f92672">-</span> windowSize <span style="color:#f92672">==</span> windows.front())<span style="color:#75715e">//窗口超了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			windows.pop_front();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&gt;=</span> windowSize <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)<span style="color:#75715e">//第一个窗口是否形成
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			ans[index<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> a[windows.front()];
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="差值小于aim的子数组数量">差值小于aim的子数组数量</h3>
<p>首先定义子数组，必须是数组中位置连续的数，顺序必须和数组中的位置相同。长度n的数组，从0至n-1，从1至n-1&hellip;&hellip;.共(n+1)n/2个子数组。</p>
<p>给定一个数组和一个值aim，返回所有最大值减去最小值小于等于aim的子数组数量。时间复杂度<code>O(N)</code></p>
<p>分析：首先，从x至y位置子数组满足条件时，那么从x至y位置的子数组都满足条件，因为最大值只可能变小最小值只可能变大，所以差值只可能变小，所以一定满足条件。从x至y位置子数组不满足条件时，无论时扩充左边还是扩充右边，都不能满足条件，因为扩充只能让最大值变大，最小值变小，差值只可能变大，所以扩充必然不能满足条件。遍历数组从0位置开始，每到一个就从队尾加入窗口，用两个双端队列记录窗口最大值和最小值，当加入某个位置x时，发现不满足条件，这时候0到x-1满足条件并且其子数组均满足条件，并且在扩充都不能满足条件，这样就找到了以0开头的所有满足条件的子数组，0-0&hellip;&hellip;0-x-1，总共x个，然后队头出去，同样操作找到从1开头的所有子数组，直到结尾。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">numOfSubArray</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> target, <span style="color:#66d9ef">int</span> length) {
</span></span><span style="display:flex;"><span>	deque<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> min, max;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, end <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> length; <span style="color:#f92672">++</span>i) {<span style="color:#75715e">//find subarray head of i
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">while</span> (end <span style="color:#f92672">&lt;</span> length) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>min.empty() <span style="color:#f92672">&amp;&amp;</span> a[end] <span style="color:#f92672">&lt;=</span> a[min.back()])
</span></span><span style="display:flex;"><span>				min.pop_back();
</span></span><span style="display:flex;"><span>			min.push_back(end);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>max.empty() <span style="color:#f92672">&amp;&amp;</span> a[end] <span style="color:#f92672">&gt;=</span> a[max.back()])
</span></span><span style="display:flex;"><span>				max.pop_back();
</span></span><span style="display:flex;"><span>			max.push_back(end);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (max.front() <span style="color:#f92672">-</span> min.front() <span style="color:#f92672">&gt;</span> target)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>			end<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		ans <span style="color:#f92672">+=</span> end <span style="color:#f92672">-</span> i;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (max.front() <span style="color:#f92672">==</span> i)<span style="color:#75715e">//如果头是i，删除i，以i开头的找齐了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			max.pop_front();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (min.front() <span style="color:#f92672">==</span> i)
</span></span><span style="display:flex;"><span>			min.pop_front();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="滑动窗口范式">滑动窗口范式</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">slidingwindows</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> nums,<span style="color:#66d9ef">int</span> k){
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">先预处理</span>
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">然后进行滑动窗的循环，一般是个</span>while循环<span style="color:#960050;background-color:#1e0010">，同时实现定义好滑动窗的起点和终点，同时还有一个是记录当前状态的数或者数组，比如</span>count
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> begin <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, end <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(end<span style="color:#f92672">&lt;</span>nums.size()){
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">1.</span><span style="color:#960050;background-color:#1e0010">在循环里先是当前</span>end到达的时候<span style="color:#960050;background-color:#1e0010">，更新</span>count
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">2.</span><span style="color:#960050;background-color:#1e0010">判断更新完后是否满足条件，比如</span>count<span style="color:#f92672">&lt;</span>k
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">3.</span><span style="color:#960050;background-color:#1e0010">如果满足的话，可以进行一些处理，如果是求最小长度之类的，会在满足时进行操作</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">4.</span><span style="color:#960050;background-color:#1e0010">如果不满足的话，也需要进行一些处理，比如求最大长度之类的，会在此时进行操作</span>
</span></span><span style="display:flex;"><span>     <span style="color:#960050;background-color:#1e0010">以上</span><span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span><span style="color:#960050;background-color:#1e0010">条常见的操作就是一个</span>while循环<span style="color:#960050;background-color:#1e0010">，进行左边界</span>begin的收缩处理<span style="color:#960050;background-color:#1e0010">，一直到收缩到满足</span><span style="color:#f92672">/</span><span style="color:#960050;background-color:#1e0010">不满足条件为止</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>最短子数组问题</strong></p>
<p>给定数组和边界值aim，找出和大于等于aim的最短子数组</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">minSubArrayLen</span>(<span style="color:#66d9ef">int</span> s, <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> nums, <span style="color:#66d9ef">int</span> numsSize) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">9999</span>, end <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> numsSize; <span style="color:#f92672">++</span>i) {<span style="color:#75715e">//每次循环代表以i开头的子数组中找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> (; end <span style="color:#f92672">&lt;</span> numsSize; <span style="color:#f92672">++</span>end) {
</span></span><span style="display:flex;"><span>			sum <span style="color:#f92672">+=</span> nums[end];
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (sum <span style="color:#f92672">&gt;=</span> s)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//end=numsize说明找到和最后一个都没有超过s，那么更新左边界再找就没有意义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (end <span style="color:#f92672">==</span> numsSize)          
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		ans <span style="color:#f92672">=</span> (ans <span style="color:#f92672">&lt;</span> end <span style="color:#f92672">-</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">?</span> ans : end <span style="color:#f92672">-</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		sum <span style="color:#f92672">=</span> sum <span style="color:#f92672">-</span> nums[i] <span style="color:#f92672">-</span> nums[end];
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> (ans <span style="color:#f92672">==</span> <span style="color:#ae81ff">9999</span>) <span style="color:#f92672">?</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">:</span> ans;<span style="color:#75715e">//如果没有子数组和大于等于s返回0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>更加简洁的解法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">minSubArrayLen</span>(<span style="color:#66d9ef">int</span> s, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> begin <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,end <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> INT_MAX;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(end<span style="color:#f92672">&lt;</span>(<span style="color:#66d9ef">int</span>)nums.size()){
</span></span><span style="display:flex;"><span>        count <span style="color:#f92672">+=</span> nums[end<span style="color:#f92672">++</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(count<span style="color:#f92672">&gt;=</span> s){<span style="color:#75715e">//更新左边界
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            res <span style="color:#f92672">=</span> min(res,end<span style="color:#f92672">-</span>begin);
</span></span><span style="display:flex;"><span>            count <span style="color:#f92672">-=</span> nums[begin<span style="color:#f92672">++</span>];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (res<span style="color:#f92672">==</span>INT_MAX)<span style="color:#f92672">?</span><span style="color:#ae81ff">0</span><span style="color:#f92672">:</span>res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>无重复字符的最长子串</strong></p>
<p>给定一字符串求无重复字符的最长子串的长度</p>
<p>输入 abcdae         输出 5</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxDiffString</span>(string s) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> end <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	unordered_map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> help;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (end <span style="color:#f92672">&lt;</span> s.length()) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (help.find(s[end]) <span style="color:#f92672">==</span> help.end()) 
</span></span><span style="display:flex;"><span>			help.insert({ s[end], end });
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			ans <span style="color:#f92672">=</span> max(ans, end <span style="color:#f92672">-</span> start);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (help[s[end]] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;=</span> start)<span style="color:#75715e">//找到的字符下一个位置在当前start后面才更新 abba
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				start <span style="color:#f92672">=</span> help[s[end]] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>			help[s[end]] <span style="color:#f92672">=</span> end;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		end<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> max(ans, end <span style="color:#f92672">-</span> start);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="part-3--单调栈">Part 3  单调栈</h2>
<p>一个普通栈，元素必须保证从栈底到栈顶从小到大或者从大到小。</p>
<h3 id="最近的大数">最近的大数</h3>
<p>给定一个数组，求出每个位置离他左边最近和右边最近比他大的数，没有的话记为-1</p>
<p>输入：1 2 3     输出  左 -1 -1 -1  右 2 3 -1</p>
<p>分析：暴力法遍历每个位置然后向两边扩，时间复杂度<code>O(N^2)</code>。利用单调栈，保证从栈底到栈顶从大到小。遍历每个数每个数都要进栈，当即将进栈的元素小于等于栈顶元素时，直接进栈。当即将进栈元素大于栈顶元素时，为了保持单调栈栈顶元素出栈，这时候我们就可以发现，出栈元素右边最近的大数就是即将进栈元素，左边最近的大数就是栈里面她下面的数，它下面没有数说明左边没有大数。全部数据进栈完成后，如果栈不为空，那么没有元素再进栈了，就是说右边没有元素了，这时候单调栈里面的元素右边都没有大数，左边的大数就是自己底下的数，<strong>每个数出栈时判断左右的大数</strong>。这个过程每个元素进栈出栈各一次，<strong>时间复杂度<code>O(N)</code>，空间复杂度<code>O(N)</code></strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">nearBigNum</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> length, <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#f92672">&amp;</span>leftBigNum, <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#f92672">&amp;</span>rightBigNum) {
</span></span><span style="display:flex;"><span>	stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> help;
</span></span><span style="display:flex;"><span>	leftBigNum <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[length];
</span></span><span style="display:flex;"><span>	rightBigNum <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[length];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> length; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>help.empty() <span style="color:#f92672">&amp;&amp;</span> a[i] <span style="color:#f92672">&gt;</span> a[help.top()]) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> help.top();
</span></span><span style="display:flex;"><span>			help.pop();
</span></span><span style="display:flex;"><span>			rightBigNum[temp] <span style="color:#f92672">=</span> a[i];
</span></span><span style="display:flex;"><span>			leftBigNum[temp] <span style="color:#f92672">=</span> (help.empty()) <span style="color:#f92672">?</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> a[help.top()];
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		help.push(i);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>help.empty()) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> help.top();
</span></span><span style="display:flex;"><span>		help.pop();
</span></span><span style="display:flex;"><span>		rightBigNum[temp] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		leftBigNum[temp] <span style="color:#f92672">=</span> (help.empty()) <span style="color:#f92672">?</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> a[help.top()];
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="最大矩形问题">最大矩形问题</h3>
<p>给定一个矩阵数组，值只有0和1。只有1能组成矩形，求出包含的矩形中的最大面积，包含1个1，面积为1。</p>
<p>输入  1 0 1 1            输出   6
1 1 1 1<br>
​          1 1 1 0</p>
<p>分析：解决这个问题先解决一个问题：给一个数组，每个位置代表这个位置的高度，求解这个数组所表示的最大矩形面积。以下图为例，最大矩形为3*3=9。这就是一个找最近小数的过程，找矩形面积重要的是看看每个位置能不能向两边扩展，如果左右两边比它高就可以扩展否则不能扩展。这就转化为求解距离他最近的比他小的数位置，利用单调栈<code>O(N)</code>时间内即可求出，左右位置，作差乘以当前位置高度即为矩形面积。</p>
<p><img src="https://raw.githubusercontent.com/xiaoqiao12138/PicBackUp/main/img/20210701153427.png" alt="在这里插入图片描述"></p>
<p>那么接下来，我们对将给的矩阵按行分为一行一行的，求解以每一行为底的最大矩形面积，取最大值即为所求。这里第一行高度数据可以直接利用矩阵的第一行，从第二行开始就和它的上面一行有关系，如果它为0，不管他上面有没有，底为0表示的高度只能为0，底不为0，就加上上面位置的高度，这样就能求出以每一行为底的最大矩形面积，取最大值即为所求。<strong>时间复杂度<code>O(M*N)</code></strong>，非常快，相当于遍历矩阵一次就出来了</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">nearMaxAera</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> list) {
</span></span><span style="display:flex;"><span>	stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> help;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> left, maxRec <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">int</span>)list.size(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>help.empty() <span style="color:#f92672">&amp;&amp;</span> list[i] <span style="color:#f92672">&lt;</span> list[help.top()]) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> help.top();
</span></span><span style="display:flex;"><span>			help.pop();
</span></span><span style="display:flex;"><span>			left <span style="color:#f92672">=</span> (help.empty()) <span style="color:#f92672">?</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> help.top();
</span></span><span style="display:flex;"><span>			maxRec <span style="color:#f92672">=</span> max(list[temp] <span style="color:#f92672">*</span> (i <span style="color:#f92672">-</span> left <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>), maxRec);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		help.push(i);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>help.empty()) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> help.top();
</span></span><span style="display:flex;"><span>		help.pop();
</span></span><span style="display:flex;"><span>		left <span style="color:#f92672">=</span> (help.empty()) <span style="color:#f92672">?</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> help.top();
</span></span><span style="display:flex;"><span>		maxRec <span style="color:#f92672">=</span> max(list[temp] <span style="color:#f92672">*</span> ((<span style="color:#66d9ef">int</span>)list.size() <span style="color:#f92672">-</span> left <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>), maxRec);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> maxRec;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxRecInMatrix</span>(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> matrix) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> maxAera <span style="color:#f92672">=</span> nearMaxAera(matrix[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">int</span>)matrix.size(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">int</span>)matrix[i].size(); <span style="color:#f92672">++</span>j)
</span></span><span style="display:flex;"><span>			matrix[i][j] <span style="color:#f92672">+=</span> (matrix[i][j] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">?</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">:</span> matrix[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j];
</span></span><span style="display:flex;"><span>		maxAera <span style="color:#f92672">=</span> max(maxAera, nearMaxAera(matrix[i]));
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> maxAera;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> height, width;
</span></span><span style="display:flex;"><span>	cin <span style="color:#f92672">&gt;&gt;</span> height <span style="color:#f92672">&gt;&gt;</span> width;
</span></span><span style="display:flex;"><span>	vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> a(height);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> height; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		a[i].resize(width);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;::</span>iterator i <span style="color:#f92672">=</span> a.begin(); i <span style="color:#f92672">!=</span> a.end(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator j <span style="color:#f92672">=</span> (<span style="color:#f92672">*</span>i).begin(); j <span style="color:#f92672">!=</span> (<span style="color:#f92672">*</span>i).end(); <span style="color:#f92672">++</span>j) {
</span></span><span style="display:flex;"><span>			cin <span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">*</span>j;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> maxRecInMatrix(a) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="环形山问题">环形山问题</h3>
<p>给定一个数组，表示一个环形山峰，数值表示山峰高度。定义两条规则：1)相邻的位置可见  2)两位置之间没有比两位置高度最小值高的山峰可见，山峰高度可相同。不满足规则的都不可见，求可见山峰对数量(1,2)(2,1)算一对</p>
<p>分析：单调栈找左右第一个比自己大的数呗。这里有个不一样的地方，由于两个相等高度的山峰之间是相互可见的，所以我们也需要记录这些山峰对。这次单调栈存一个特殊的结构，里面存山峰位置和当前遍历的长度中相等山峰高度的数量。我们计数时山峰对只记录第一个山峰小于等于第二个山峰的山峰对，否则会有重复。由于我们找左右两边的大数，单调栈从栈底到栈顶由大到小，进出栈规则和之前相同，只是进栈高度和栈顶高度高度相等时，栈顶高度出现的次数加一。就说明左右两边的大数找到了，可以计算结果了。那么根据单调栈，栈底元素和最后的栈顶元素是没有左边或者右边的大数的，但是本题要求循环山峰，所以左边右边应该要找，那么从哪里开始遍历就需要考虑。我们先把山峰高度最大值放进单调栈，这样保证了之后任何值左右两边都能找到大数。那么现在某个数出栈时，说明要计数了，已知左右两边找到了两个大数，假设这座山峰出现次数k，山峰对由两部分组成，一部分是k个相同的山峰之间的山峰对，那么就有<code>C(2,K)</code>对，第二部分是k个相同山峰都可以向左向右找到两边的大数，那么就有<code>2*K</code>对，一般情况就<code>C(2,K)+2*K</code>对。当遍历数组一次后，依次出栈，首先由于循环，出栈的每个元素右边的大数都为最大值，这时候如果栈内的元素数量大于2，说明左边的大数不是最大值，这样还是<code>C(2,K)+2*K</code>对。如果当前栈内只有两个元素，那么出栈元素的左右大数均为最大值，如果最大值只出现一次，那么说明k个相同的山峰只能找到一个从左边或者右边找到同一个大数，此时计数<code>C(2,K)+2*K</code>，如果最大值出现大于一次，左右的大数不是一个山峰和普通情况一样。接下来最大值山峰出栈，它只能找和自身高度相等的山峰组成山峰对，所以直接<code>C(2,K)</code>即可。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">node</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> times;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> loc;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">loopMountain</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> mountain) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (mountain.size() <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> maxLoc <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">int</span>)mountain.size(); <span style="color:#f92672">++</span>i) <span style="color:#75715e">//find max in vector
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		maxLoc <span style="color:#f92672">=</span> (mountain[maxLoc] <span style="color:#f92672">&lt;</span> mountain[i]) <span style="color:#f92672">?</span> i : maxLoc;
</span></span><span style="display:flex;"><span>	stack<span style="color:#f92672">&lt;</span>node<span style="color:#f92672">&gt;</span> help;
</span></span><span style="display:flex;"><span>	node temp{ <span style="color:#ae81ff">1</span>,maxLoc };
</span></span><span style="display:flex;"><span>	help.push(temp); <span style="color:#75715e">//initial the help stack
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> (maxLoc <span style="color:#f92672">==</span> mountain.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">?</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">:</span> maxLoc <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">//process loop nextloc
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> (i <span style="color:#f92672">!=</span> maxLoc) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>help.empty() <span style="color:#f92672">&amp;&amp;</span> mountain[i] <span style="color:#f92672">&gt;</span> mountain[help.top().loc]) {
</span></span><span style="display:flex;"><span>			ans <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> help.top().times;
</span></span><span style="display:flex;"><span>			ans <span style="color:#f92672">+=</span> (help.top().times <span style="color:#f92672">*</span> (help.top().times <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>; <span style="color:#75715e">//C(2,K)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			help.pop();
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (mountain[help.top().loc] <span style="color:#f92672">==</span> mountain[i] <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>help.empty())
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">++</span>help.top().times;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			temp.loc <span style="color:#f92672">=</span> i; temp.times <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>			help.push(temp);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		i <span style="color:#f92672">=</span> (i <span style="color:#f92672">==</span> mountain.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">?</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">:</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>help.empty()) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> times <span style="color:#f92672">=</span> help.top().times;
</span></span><span style="display:flex;"><span>		ans <span style="color:#f92672">+=</span> (times <span style="color:#f92672">*</span> (times <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>		help.pop();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (help.size() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>			ans <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> times;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (help.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>			ans <span style="color:#f92672">+=</span> (help.top().times <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">?</span> times : <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> times;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="第十讲">第十讲</h1>
<h2 id="part-1--morris遍历">Part 1  Morris遍历</h2>
<p>时间复杂度<code>O(N)</code>，空间复杂度<code>O(1)</code></p>
<p>Morris遍历规则： <strong>本质上是二叉树的线索化，利用叶子的空指针指向后继，遍历过后恢复</strong></p>
<ol>
<li>cur无左孩子，cur向右移动，<code>cur=cur-&gt;rchild</code></li>
<li>cur有左孩子，找到cur左子树上的最右结点，即为MostRight。</li>
<li>如果MostRight的右孩子指向空，让其指向cur，cur向左移动，<code>cur=cur-&gt;lchild</code></li>
<li>如果MostRight指向cur，让cur指向空，cur向右移动，<code>cur=cur-&gt;rchild</code></li>
</ol>
<p>根据Morris规则，有左孩子的结点会遍历两次，遍历左子树再顺着左子树的最右边结点的线索找回来，同时复原叶子结点，我们选择合适的时机打印cur的值就可以做到二叉树的前中后序遍历。</p>
<h3 id="前序-1">前序</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">MorrisTraversePre</span>(BiTree T) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (T <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	BiTNode<span style="color:#f92672">*</span> cur <span style="color:#f92672">=</span> T, <span style="color:#f92672">*</span> mostRight;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (cur <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (cur<span style="color:#f92672">-&gt;</span>lchild <span style="color:#f92672">!=</span> NULL) { 
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//cur has left-child, traverse second times, print cur at the first time
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			mostRight <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>lchild;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">while</span> (mostRight<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> mostRight<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">!=</span> cur)
</span></span><span style="display:flex;"><span>				mostRight <span style="color:#f92672">=</span> mostRight<span style="color:#f92672">-&gt;</span>rchild;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (mostRight<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//arrive at cur first time, mostRight point to NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				cout <span style="color:#f92672">&lt;&lt;</span> cur<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>; 
</span></span><span style="display:flex;"><span>				mostRight<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">=</span> cur;
</span></span><span style="display:flex;"><span>				cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>lchild;
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span> <span style="color:#75715e">//arrive at cur second times, mostRight point to cur
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				mostRight<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">=</span> NULL; 
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span> <span style="color:#75715e">//cur has not left-child, traverse only once, so print cur
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			cout <span style="color:#f92672">&lt;&lt;</span> cur<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>; 
</span></span><span style="display:flex;"><span>		cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>rchild;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="中序-1">中序</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">MorrisTraverseIn</span>(BiTree T) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (T <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	BiTNode<span style="color:#f92672">*</span> cur <span style="color:#f92672">=</span> T, <span style="color:#f92672">*</span> mostRight;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (cur <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (cur<span style="color:#f92672">-&gt;</span>lchild <span style="color:#f92672">!=</span> NULL) { 
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//cur has left-child, traverse second times, print cur at the second time
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			mostRight <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>lchild;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">while</span> (mostRight<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> mostRight<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">!=</span> cur)
</span></span><span style="display:flex;"><span>				mostRight <span style="color:#f92672">=</span> mostRight<span style="color:#f92672">-&gt;</span>rchild;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (mostRight<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>				mostRight<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">=</span> cur;
</span></span><span style="display:flex;"><span>				cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>lchild;
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span> <span style="color:#75715e">//arrive at cur second times, mostRight point to cur
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				mostRight<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">=</span> NULL; 
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//cur has not left-child, traverse only once, so print cur
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		cout <span style="color:#f92672">&lt;&lt;</span> cur<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>; 
</span></span><span style="display:flex;"><span>		cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>rchild;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="后序-1">后序</h3>
<p>按右边界划分二叉树，第二次访问cur时打印左子树的右边界的逆序。我们结点是顺序的，不能用额外的空间比如栈去存，所以我们定制一个<code>printEdge()</code>先将右边界逆序，就是链表的逆置，然后正常打印，最后复原树。</p>
<p><img src="https://raw.githubusercontent.com/xiaoqiao12138/PicBackUp/main/img/20210701153432.png" alt="image-20200228122043840"></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">BiTNode</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> data;
</span></span><span style="display:flex;"><span>	BiTNode<span style="color:#f92672">*</span> lchild;
</span></span><span style="display:flex;"><span>	BiTNode<span style="color:#f92672">*</span> rchild;
</span></span><span style="display:flex;"><span>}BiTNode, <span style="color:#f92672">*</span> BiTree;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printEdge</span>(BiTree T) {
</span></span><span style="display:flex;"><span>	BiTNode<span style="color:#f92672">*</span> parent <span style="color:#f92672">=</span> T, <span style="color:#f92672">*</span> child, <span style="color:#f92672">*</span> grandParent <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (parent <span style="color:#f92672">!=</span> NULL) { <span style="color:#75715e">//先把右边界逆序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		child <span style="color:#f92672">=</span> parent<span style="color:#f92672">-&gt;</span>rchild;
</span></span><span style="display:flex;"><span>		parent<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">=</span> grandParent;
</span></span><span style="display:flex;"><span>		grandParent <span style="color:#f92672">=</span> parent;
</span></span><span style="display:flex;"><span>		parent <span style="color:#f92672">=</span> child;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	parent <span style="color:#f92672">=</span> grandParent;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (parent <span style="color:#f92672">!=</span> NULL) { <span style="color:#75715e">//逆序打印右边界
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		cout <span style="color:#f92672">&lt;&lt;</span> parent<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>		parent <span style="color:#f92672">=</span> parent<span style="color:#f92672">-&gt;</span>rchild;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	parent <span style="color:#f92672">=</span> grandParent;
</span></span><span style="display:flex;"><span>	grandParent <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (parent <span style="color:#f92672">!=</span> NULL) { <span style="color:#75715e">//恢复右边界
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		child <span style="color:#f92672">=</span> parent<span style="color:#f92672">-&gt;</span>rchild;
</span></span><span style="display:flex;"><span>		parent<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">=</span> grandParent;
</span></span><span style="display:flex;"><span>		grandParent <span style="color:#f92672">=</span> parent;
</span></span><span style="display:flex;"><span>		parent <span style="color:#f92672">=</span> child;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">MorrisTraversePos</span>(BiTree T) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (T <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>	BiTNode<span style="color:#f92672">*</span> cur <span style="color:#f92672">=</span> T, <span style="color:#f92672">*</span> mostRight;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (cur <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (cur<span style="color:#f92672">-&gt;</span>lchild <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//cur has left-child, traverse second times, print cur at the second time
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			mostRight <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>lchild;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">while</span> (mostRight<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> mostRight<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">!=</span> cur)
</span></span><span style="display:flex;"><span>				mostRight <span style="color:#f92672">=</span> mostRight<span style="color:#f92672">-&gt;</span>rchild;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (mostRight<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>				mostRight<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">=</span> cur;
</span></span><span style="display:flex;"><span>				cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>lchild;
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//arrive at cur second times, mostRight point to cur
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				mostRight<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">=</span> NULL; 
</span></span><span style="display:flex;"><span>				printEdge(cur<span style="color:#f92672">-&gt;</span>lchild);				
</span></span><span style="display:flex;"><span>			}				
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>rchild;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	printEdge(T);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="用morrs遍历解决重构搜索二叉树的判断">用Morrs遍历解决重构搜索二叉树的判断</h3>
<p>原来的搜索二叉树的判断是非递归版中序遍历，要用额外的空间，用Morris遍历来优化。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isBSTMorris</span>(BiTree T) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (T <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>	BiTNode<span style="color:#f92672">*</span> cur <span style="color:#f92672">=</span> T, <span style="color:#f92672">*</span> mostRight;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> temp<span style="color:#f92672">=-</span><span style="color:#ae81ff">999</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (cur <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (cur<span style="color:#f92672">-&gt;</span>lchild <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//cur has left-child, traverse second times, print cur at the second time
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			mostRight <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>lchild;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">while</span> (mostRight<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> mostRight<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">!=</span> cur)
</span></span><span style="display:flex;"><span>				mostRight <span style="color:#f92672">=</span> mostRight<span style="color:#f92672">-&gt;</span>rchild;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (mostRight<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>				mostRight<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">=</span> cur;
</span></span><span style="display:flex;"><span>				cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>lchild;
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span> 
</span></span><span style="display:flex;"><span>				mostRight<span style="color:#f92672">-&gt;</span>rchild <span style="color:#f92672">=</span> NULL; <span style="color:#75715e">//arrive at cur second times, mostRight point to cur			
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (temp <span style="color:#f92672">&gt;</span> cur<span style="color:#f92672">-&gt;</span>data)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>		temp <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>data;
</span></span><span style="display:flex;"><span>		cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">-&gt;</span>rchild;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="part-2--avl树">Part 2  AVL树</h2>

</div>


    </main>

    
      
    
  </body>
</html>
